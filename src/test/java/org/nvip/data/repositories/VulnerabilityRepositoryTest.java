package org.nvip.data.repositories;

import jakarta.persistence.EntityManager;
import jakarta.persistence.PersistenceContext;
import jakarta.persistence.criteria.CriteriaBuilder;
import jakarta.persistence.criteria.CriteriaQuery;
import jakarta.persistence.criteria.Root;
import jakarta.transaction.Transactional;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.junit.runner.RunWith;
import org.nvip.entities.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.junit4.SpringRunner;

import java.time.Instant;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.*;

import static org.junit.jupiter.api.Assertions.*;


@RunWith(SpringRunner.class)
@SpringBootTest
public class VulnerabilityRepositoryTest {

    final int DEFAULT_LIMIT = 5;

    @PersistenceContext
    EntityManager entityManager;

    @Autowired
    VulnRepository vulnRepository;

    @Autowired
    VulnerabilityRepository repository;

    @Test
    @Transactional
    void testGetByCveIdReturnsNothingWhenNoVulnerabilitiesFound(){
        Vulnerability vulnerability = vulnRepository.findByCveId("CVE-1234-5678");
        assertNull(vulnerability);
    }

    @Test
    @Transactional
    void testGetByCveIdReturnsVulnWhenOneVulnerabilitiesFound(){
        Vulnerability vuln = new Vulnerability(1, "CVE-1234-5678", LocalDateTime.now(), LocalDateTime.now(), LocalDateTime.now());
        entityManager.persist(vuln);

        Vulnerability vulnerability = vulnRepository.findByCveId("CVE-1234-5678");
        assertEquals("CVE-1234-5678", vulnerability.getCveId());

        entityManager.remove(vuln);
    }

    @Nested
    class SearchResults {

        @Test
        @Transactional
        void testItReturnsOrderedByExistInNvdAndVulnId(){
            Random rd = new Random();
            List<Vulnerability> insertedVulns = new ArrayList<>();
            int limit = 5;
            for(int i = 0; i < limit + 1; i++){
                Vulnerability vuln = new Vulnerability(i, "CVE-1234-567"+i, LocalDateTime.now(), LocalDateTime.now(), LocalDateTime.now());
                Description desc = new Description(i, "Description", LocalDateTime.now(), "gpt", 1);
                vuln.setDescription(desc);
                entityManager.persist(vuln);
                entityManager.persist(desc);
                insertedVulns.add(vuln);
            }
            insertedVulns.sort(
                    Comparator.comparing(Vulnerability::getVulnId, Comparator.reverseOrder())
            );

            List<Vulnerability> vulnerabilities = repository.searchVulnerability(null, null, null, null, null, limit, null);

            assertEquals(insertedVulns.subList(0, limit), vulnerabilities);

            for(int i = 0; i < limit + 1; i++){
                Vulnerability vuln = entityManager.getReference(Vulnerability.class, i);
                entityManager.remove(vuln);
                entityManager.remove(entityManager.getReference(Description.class, i));
            }
        }

        @Test
        @Transactional
        void testItReturnsNumberOfVulnsEqualToLimit(){
            int limit = 5;
            for(int i = 0; i < limit + 1; i++){
                Vulnerability vuln = new Vulnerability(i, "CVE-1234-567"+i, LocalDateTime.now(), LocalDateTime.now(), LocalDateTime.now());
                Description desc = new Description(i, "Description", LocalDateTime.now(), "gpt", 1);
                vuln.setDescription(desc);
                entityManager.persist(vuln);
                entityManager.persist(desc);
            }

            List<Vulnerability> vulnerabilities = repository.searchVulnerability(null, null, null, null, null, limit, null);
            assertFalse(vulnerabilities.isEmpty());
            assertEquals(limit, vulnerabilities.size());

            for(int i = 0; i < limit + 1; i++){
                Vulnerability vuln = entityManager.getReference(Vulnerability.class, i);
                entityManager.remove(vuln);
                entityManager.remove(entityManager.getReference(Description.class, i));
            }
        }

        @Test
        @Transactional
        void testItReturnsVulnsGTEStartDate(){

            List<Vulnerability> vulns = new ArrayList<>();
            List<Description> descs = new ArrayList<>();
            int max_day = 5;
            for(int i = 1; i <= max_day; i++){
                Vulnerability vuln = new Vulnerability(i, "CVE-1234-567"+i, LocalDateTime.now(), LocalDateTime.now(), LocalDateTime.parse("2018-01-0"+i+"T00:00:00"));
                Description desc = new Description(i, "Description", LocalDateTime.now(), "gpt", 1);
                vuln.setDescription(desc);
                entityManager.persist(vuln);
                entityManager.persist(desc);
                vulns.add(vuln);
                descs.add(desc);
            }

            List<Vulnerability> vulnerabilities = repository.searchVulnerability("Description", LocalDateTime.parse("2018-01-0"+max_day+"T00:00:00"), null, null, null, DEFAULT_LIMIT, null);
            assertEquals(1, vulnerabilities.size());

            vulns.forEach(x -> entityManager.remove(x));
            descs.forEach(x -> entityManager.remove(x));
        }

        @Test
        @Transactional
        void testItReturnsVulnsLTEEndDate(){
            List<Vulnerability> vulns = new ArrayList<>();
            List<Description> descs = new ArrayList<>();
            int max_day = 5;
            for(int i = 1; i <= max_day; i++){
                Vulnerability vuln = new Vulnerability(i, "CVE-1234-567"+i, LocalDateTime.now(), LocalDateTime.now(), LocalDateTime.parse("2018-01-0"+i+"T00:00:00"));
                Description desc = new Description(i, "Description", LocalDateTime.now(), "gpt", 1);
                vuln.setDescription(desc);
                entityManager.persist(vuln);
                entityManager.persist(desc);
                vulns.add(vuln);
                descs.add(desc);
            }

            List<Vulnerability> vulnerabilities = repository.searchVulnerability("Description", null, LocalDateTime.parse("2018-01-0"+max_day+"T00:00:00"), null, null, DEFAULT_LIMIT, null);
            assertEquals(5, vulnerabilities.size());

            vulns.forEach(x -> entityManager.remove(x));
            descs.forEach(x -> entityManager.remove(x));
        }

        @Test
        @Transactional
        void testItReturnsVulnsWithSimilarProducts(){
            int limit = 5;
            for(int i = 0; i < limit + 1; i++){
                Vulnerability vuln = new Vulnerability(i, "CVE-1234-567"+i, LocalDateTime.now(), LocalDateTime.now(), LocalDateTime.now());
                Description desc = new Description(i, "Description", LocalDateTime.now(), "gpt", 1);
                vuln.setDescription(desc);
                entityManager.persist(vuln);
                entityManager.persist(desc);

                AffectedProduct affectedRelease = new AffectedProduct(i, vuln, "cpe", "product", "Version", "vendor", "purl", "swid_tag");
                entityManager.persist(affectedRelease);
            }

            List<Vulnerability> vulnerabilities = repository.searchVulnerability(null, null, null, null, null, limit, "p");
            assertEquals(limit, vulnerabilities.size());

            for(int i = 0; i < limit + 1; i++){
                Vulnerability vuln = entityManager.getReference(Vulnerability.class, i);
                entityManager.remove(vuln);
                entityManager.remove(entityManager.getReference(Description.class, i));
            }
        }

        @Test
        @Transactional
        void testItFiltersOutMisMatchingProducts(){
            int limit = 5;
            for(int i = 0; i < limit + 1; i++){
                Vulnerability vuln = new Vulnerability(i, "CVE-1234-567"+i, LocalDateTime.now(), LocalDateTime.now(), LocalDateTime.now());
                Description desc = new Description(i, "Description", LocalDateTime.now(), "gpt", 1);
                vuln.setDescription(desc);
                entityManager.persist(vuln);
                entityManager.persist(desc);

                AffectedProduct affectedRelease = new AffectedProduct(i, vuln, "cpe", "product", "Version", "vendor", "purl", "swid_tag");
                entityManager.persist(affectedRelease);
            }

            List<Vulnerability> vulnerabilities = repository.searchVulnerability(null, null, null, null, null, limit, "SomethingElse");
            assertEquals(0, vulnerabilities.size());

            for(int i = 0; i < limit + 1; i++){
                entityManager.remove(entityManager.getReference(Vulnerability.class, i));
                entityManager.remove(entityManager.getReference(AffectedProduct.class, i));
                entityManager.remove(entityManager.getReference(Description.class, i));
            }
        }

        @Test
        @Transactional
        void testItFiltersOutMismatchedSeverityClasses(){
            int limit = 5;
            int[] cvssIds = new int[limit+1];
            for(int i = 0; i < limit + 1; i++){
                Vulnerability vuln = new Vulnerability(i, "CVE-1234-567"+i, LocalDateTime.now(), LocalDateTime.now(), LocalDateTime.now());
                Description desc = new Description(i, "Description", LocalDateTime.now(), "gpt", 1);
                vuln.setDescription(desc);
                entityManager.persist(vuln);
                entityManager.persist(desc);

                Cvss cvssScore = new Cvss(vuln, 1);
                entityManager.persist(cvssScore);
                entityManager.flush();
                cvssIds[i] = cvssScore.getId();
            }

            int[] ints = {1};
            List<Vulnerability> vulnerabilities = repository.searchVulnerability(null, null, null, ints, null, limit, null);
            assertEquals(limit, vulnerabilities.size());

            for(int i = 0; i < limit + 1; i++){
                entityManager.remove(entityManager.getReference(Cvss.class, cvssIds[i]));
                entityManager.remove(entityManager.getReference(Vulnerability.class, i));
                entityManager.remove(entityManager.getReference(Description.class, i));
            }
        }

        @Test
        @Transactional
        void testItFiltersOutMismatchedVdoLabels(){
            int limit = 5;
            int[] vdoIds = new int[limit+1];
            for(int i = 0; i < limit + 1; i++){
                Vulnerability vuln = new Vulnerability(i, "CVE-1234-567"+i, LocalDateTime.now(), LocalDateTime.now(), LocalDateTime.now());
                Description desc = new Description(i, "Description", LocalDateTime.now(), "gpt", 1);
                vuln.setDescription(desc);
                entityManager.persist(vuln);
                entityManager.persist(desc);

                VdoCharacteristic characteristic = new VdoCharacteristic(vuln, "Label", "Group", 1.0d);
                entityManager.persist(characteristic);
                entityManager.flush();
                vdoIds[i] = characteristic.getId();
            }

            List<Vulnerability> vulnerabilities = repository.searchVulnerability(null, null, null, null, Arrays.asList("Label").toArray(new String[0]), limit, null);
            assertEquals(limit, vulnerabilities.size());

            for(int i = 0; i < limit + 1; i++){
                entityManager.remove(entityManager.getReference(VdoCharacteristic.class, vdoIds[i]));
                entityManager.remove(entityManager.getReference(Vulnerability.class, i));
                entityManager.remove(entityManager.getReference(Description.class, i));
            }
        }
    }
}
