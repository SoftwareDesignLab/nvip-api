package org.nvip.data.repositories;

import jakarta.persistence.EntityManager;
import jakarta.persistence.PersistenceContext;
import jakarta.persistence.criteria.CriteriaBuilder;
import jakarta.persistence.criteria.CriteriaQuery;
import jakarta.persistence.criteria.Root;
import jakarta.transaction.Transactional;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.junit.runner.RunWith;
import org.nvip.entities.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.junit4.SpringRunner;

import java.time.Instant;
import java.time.LocalDate;
import java.util.*;

import static org.junit.jupiter.api.Assertions.*;


@RunWith(SpringRunner.class)
@SpringBootTest
public class VulnerabilityRepositoryTest {

    final int DEFAULT_LIMIT = 5;

    @PersistenceContext
    EntityManager entityManager;

    @Autowired
    VulnerabilityRepository repository;

    @Test
    @Transactional
    void testGetByCveIdReturnsNothingWhenNoVulnerabilitiesFound(){
        Map<Integer, List<Vulnerability>> vulnerabilities = repository.getByCveId("CVE-1234-5678");
        assertTrue(vulnerabilities.isEmpty());
    }

    @Test
    @Transactional
    void testGetByCveIdReturnsVulnWhenOneVulnerabilitiesFound(){
        Vulnerability vuln = new Vulnerability(1, "CVE-1234-5678", "Description", "Platform", Instant.now().toString(), Instant.now().toString(), true, true);
        entityManager.persist(vuln);

        Map<Integer, List<Vulnerability>> vulnerabilities = repository.getByCveId("CVE-1234-5678");
        assertFalse(vulnerabilities.isEmpty());
        assertEquals(1, vulnerabilities.size());

        entityManager.remove(vuln);
    }

    @Nested
    class SearchResults {

        @Test
        @Transactional
        void testItReturnsOrderedByExistInNvdAndVulnId(){
            Random rd = new Random();
            List<Vulnerability> insertedVulns = new ArrayList<>();
            int limit = 5;
            for(int i = 0; i < limit + 1; i++){
                Vulnerability vuln = new Vulnerability(i, "CVE-1234-567"+i, "Description", "Platform", Instant.now().toString(), Instant.now().toString(), true, rd.nextBoolean());
                entityManager.persist(vuln);
                insertedVulns.add(vuln);
            }
            insertedVulns.sort(
                    Comparator.comparing(Vulnerability::isExistInNvd)
                            .thenComparing(Vulnerability::getVulnId, Comparator.reverseOrder())
            );

            Map<Integer, List<Vulnerability>> vulnerabilities = repository.searchVulnerability("Description",null, null, null, null, limit, null);

            assertEquals(insertedVulns.subList(0, limit), vulnerabilities.values().stream().findFirst().get());

            for(int i = 0; i < limit + 1; i++){
                Vulnerability vuln = entityManager.getReference(Vulnerability.class, i);
                entityManager.remove(vuln);
            }
        }

        @Test
        @Transactional
        void testItReturnsNumberOfVulnsEqualToLimit(){
            int limit = 5;
            for(int i = 0; i < limit + 1; i++){
                Vulnerability vuln = new Vulnerability(i, "CVE-1234-567"+i, "Description", "Platform", Instant.now().toString(), Instant.now().toString(), true, true);
                entityManager.persist(vuln);
            }

            Map<Integer, List<Vulnerability>> vulnerabilities = repository.searchVulnerability("Description",null, null, null, null, limit, null);
            assertFalse(vulnerabilities.isEmpty());
            assertEquals(1, vulnerabilities.size());
            assertEquals(limit, vulnerabilities.values().stream().findFirst().get().size());

            for(int i = 0; i < limit + 1; i++){
                Vulnerability vuln = entityManager.getReference(Vulnerability.class, i);
                entityManager.remove(vuln);
            }
        }

        @Test
        @Transactional
        void testItReturnsVulnsGTEStartDate(){

            List<DailyRunHistory> dailyRuns = new ArrayList<>();
            List<Vulnerability> vulns = new ArrayList<>();
            List<VulnerabilityUpdate> vulnerabilityUpdates = new ArrayList<>();
            int max_day = 5;
            for(int i = 1; i <= max_day; i++){
                DailyRunHistory dailyRunHistory = new DailyRunHistory(i, LocalDate.parse("2018-01-0"+i), 1, 1, 0.0d, 0.0d, 1, 1);
                entityManager.persist(dailyRunHistory);
                dailyRuns.add(dailyRunHistory);

                Vulnerability vuln = new Vulnerability(i, "CVE-1234-567"+i, "Description", "Platform", "2018-01-0"+i, Instant.now().toString(), true, true);
                entityManager.persist(vuln);
                vulns.add(vuln);

                VulnerabilityUpdate vulnerabilityUpdate = new VulnerabilityUpdate(i, vuln, dailyRunHistory);
                entityManager.persist(vulnerabilityUpdate);
                vulnerabilityUpdates.add(vulnerabilityUpdate);
            }

            Map<Integer, List<Vulnerability>> vulnerabilities = repository.searchVulnerability("Description", LocalDate.parse("2018-01-0"+max_day), null, null, null, DEFAULT_LIMIT, null);
            assertFalse(vulnerabilities.isEmpty());
            assertEquals(1, vulnerabilities.size());
            assertEquals(1, vulnerabilities.values().stream().findFirst().get().size());

            vulns.forEach(x -> entityManager.remove(x));
            vulnerabilityUpdates.forEach(x -> entityManager.remove(x));
            dailyRuns.forEach(x -> entityManager.remove(x));
        }

        @Test
        @Transactional
        void testItReturnsVulnsLTEEndDate(){

            List<DailyRunHistory> dailyRuns = new ArrayList<>();
            List<Vulnerability> vulns = new ArrayList<>();
            List<VulnerabilityUpdate> vulnerabilityUpdates = new ArrayList<>();
            int max_day = 5;
            for(int i = 1; i <= max_day; i++){
                DailyRunHistory dailyRunHistory = new DailyRunHistory(i, LocalDate.parse("2018-01-0"+i), 1, 1, 0.0d, 0.0d, 1, 1);
                entityManager.persist(dailyRunHistory);
                dailyRuns.add(dailyRunHistory);

                Vulnerability vuln = new Vulnerability(i, "CVE-1234-567"+i, "Description", "Platform", "2018-01-0"+i, Instant.now().toString(), true, true);
                entityManager.persist(vuln);
                vulns.add(vuln);

                VulnerabilityUpdate vulnerabilityUpdate = new VulnerabilityUpdate(i, vuln, dailyRunHistory);
                entityManager.persist(vulnerabilityUpdate);
                vulnerabilityUpdates.add(vulnerabilityUpdate);
            }

            Map<Integer, List<Vulnerability>> vulnerabilities = repository.searchVulnerability("Description", null, LocalDate.parse("2018-01-0"+1), null, null, DEFAULT_LIMIT, null);
            assertFalse(vulnerabilities.isEmpty());
            assertEquals(1, vulnerabilities.size());
            assertEquals(1, vulnerabilities.values().stream().findFirst().get().size());

            vulns.forEach(x -> entityManager.remove(x));
            vulnerabilityUpdates.forEach(x -> entityManager.remove(x));
            dailyRuns.forEach(x -> entityManager.remove(x));
        }

        @Test
        @Transactional
        void testItReturnsVulnsWithSimilarProducts(){
            int limit = 5;
            for(int i = 0; i < limit + 1; i++){
                Vulnerability vuln = new Vulnerability(i, "CVE-1234-567"+i, "Description", "Platform", Instant.now().toString(), Instant.now().toString(), true, true);
                entityManager.persist(vuln);

                Product product = new Product(i, "Platform", "Domain", "Today", "Version");
                entityManager.persist(product);

                AffectedRelease affectedRelease = new AffectedRelease(i, 1, vuln, product);
                entityManager.persist(affectedRelease);
            }

            Map<Integer, List<Vulnerability>> vulnerabilities = repository.searchVulnerability("Description",null, null, null, null, limit, "P");
            assertFalse(vulnerabilities.isEmpty());
            assertEquals(1, vulnerabilities.size());
            assertEquals(limit, vulnerabilities.values().stream().findFirst().get().size());

            for(int i = 0; i < limit + 1; i++){
                Vulnerability vuln = entityManager.getReference(Vulnerability.class, i);
                entityManager.remove(vuln);
            }
        }

        @Test
        @Transactional
        void testItFiltersOutMisMatchingProducts(){
            int limit = 5;
            for(int i = 0; i < limit + 1; i++){
                Vulnerability vuln = new Vulnerability(i, "CVE-1234-567"+i, "Description", "Platform", Instant.now().toString(), Instant.now().toString(), true, true);
                entityManager.persist(vuln);

                Product product = new Product(i, "Platform", "Domain", "Today", "Version");
                entityManager.persist(product);

                AffectedRelease affectedRelease = new AffectedRelease(i, 1, vuln, product);
                entityManager.persist(affectedRelease);
            }

            Map<Integer, List<Vulnerability>> vulnerabilities = repository.searchVulnerability("Description",null, null, null, null, limit, "SomethingElse");
            assertFalse(vulnerabilities.isEmpty());
            assertEquals(1, vulnerabilities.size());
            assertEquals(0, vulnerabilities.values().stream().findFirst().get().size());

            for(int i = 0; i < limit + 1; i++){
                entityManager.remove(entityManager.getReference(Vulnerability.class, i));
                entityManager.remove(entityManager.getReference(Product.class, i));
                entityManager.remove(entityManager.getReference(AffectedRelease.class, i));
            }
        }

        @Test
        @Transactional
        void testItFiltersOutMismatchedSeverityClasses(){
            CvssSeverity severity = new CvssSeverity(1, "High");
            entityManager.persist(severity);

            int limit = 5;
            for(int i = 0; i < limit + 1; i++){
                Vulnerability vuln = new Vulnerability(i, "CVE-1234-567"+i, "Description", "Platform", Instant.now().toString(), Instant.now().toString(), true, true);
                entityManager.persist(vuln);

                CvssScore cvssScore = new CvssScore(i, "3.0", 0.9d, "5.0", 0.9d, vuln, severity);
                entityManager.persist(cvssScore);
            }

            Map<Integer, List<Vulnerability>> vulnerabilities = repository.searchVulnerability("Description",null, null, Arrays.asList("High").toArray(new String[0]), null, limit, null);
            assertFalse(vulnerabilities.isEmpty());
            assertEquals(1, vulnerabilities.size());
            assertEquals(limit, vulnerabilities.values().stream().findFirst().get().size());

            entityManager.remove(entityManager.getReference(CvssSeverity.class, 1));
            for(int i = 0; i < limit + 1; i++){
                entityManager.remove(entityManager.getReference(Vulnerability.class, i));
                entityManager.remove(entityManager.getReference(CvssScore.class, i));
            }
        }

        @Test
        @Transactional
        void testItFiltersOutMismatchedVdoLabels(){

            int limit = 5;
            for(int i = 0; i < limit + 1; i++){
                Vulnerability vuln = new Vulnerability(i, "CVE-1234-567"+i, "Description", "Platform", Instant.now().toString(), Instant.now().toString(), true, true);
                entityManager.persist(vuln);

                VdoLabel vdoLabel = new VdoLabel(i, "Label", null);
                entityManager.persist(vdoLabel);

                VdoCharacteristic characteristic = new VdoCharacteristic(i, vuln.getCveId(), "Label", 0.9d, "Group", vuln, vdoLabel);
                entityManager.persist(characteristic);
            }

            Map<Integer, List<Vulnerability>> vulnerabilities = repository.searchVulnerability("Description",null, null, null, Arrays.asList("Lab").toArray(new String[0]), limit, null);
            assertFalse(vulnerabilities.isEmpty());
            assertEquals(1, vulnerabilities.size());
            assertEquals(limit, vulnerabilities.values().stream().findFirst().get().size());

            for(int i = 0; i < limit + 1; i++){
                entityManager.remove(entityManager.getReference(Vulnerability.class, i));
                entityManager.remove(entityManager.getReference(VdoLabel.class, i));
                entityManager.remove(entityManager.getReference(VdoCharacteristic.class, i));
            }
        }
    }
}
