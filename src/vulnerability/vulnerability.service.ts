import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Description, Vulnerability, VulnerabilityVersion } from 'src/entities';
import { Repository, SelectQueryBuilder, Brackets } from 'typeorm';
import * as moment from 'moment';
@Injectable()
export class VulnerabilityService {
    constructor(
        @InjectRepository(Vulnerability)
        private vulnerabilityRepository: Repository<Vulnerability>,
        @InjectRepository(VulnerabilityVersion)
        private vulnerabilityVersionRepository: Repository<VulnerabilityVersion>,
    ) {}
    async create(createVulnerabilityDto: any) {
        return 'This action adds a new vulnerability';
    }

    async paginate(
        options: any,
        queryBuilder: SelectQueryBuilder<Vulnerability>,
    ) {
        queryBuilder.cache(true);
        queryBuilder
            .orderBy('vulnerability.createdDate', 'DESC')
            .skip(options.skip)
            .cache(60000)
            .take(options.limit);

        const data: any[] = await queryBuilder.getMany();
        var total: number = await queryBuilder.getCount();
        for (var item of data) {
            var version = await this.vulnerabilityVersionRepository.findOne({
                where: { vulnerabilityVersionId: item.vulnVersionId },
                relations: ['description'],
            });
            item.description = version.description.description;
        }
        console.log(total);

        return { data, total };
    }

    async findAll(options: any) {
        const queryBuilder =
            this.vulnerabilityRepository.createQueryBuilder('vulnerability');
        return await this.paginate(options, queryBuilder);
    }

    async findOne(id: string) {
        const vulnerability = await this.vulnerabilityRepository.findOne({
            where: { cveId: id },
            relations: [
                'rawDescriptions',
                'vulnerabilityVersions',
                'exploits',
                'fixes',
                'ssvc',
                'affectedProducts',
                'cvssScores',
                'vulnerabilityVersions.cpeSet',
                'vulnerabilityVersions.description',
                'vulnerabilityVersions.vdoSet.vdoCharacteristics',
            ],
        });
        return vulnerability;
    }

    async search(options: any, searchParams: any) {
        const queryBuilder =
            this.vulnerabilityRepository.createQueryBuilder('vulnerability');
        if (searchParams.cveId != '') {
            queryBuilder.andWhere('vulnerability.cveId = :cveId', {
                cveId: searchParams.cveId,
            });
            return await this.paginate(options, queryBuilder);
        }

        if (searchParams.cpe != '') {
            queryBuilder.leftJoinAndSelect(
                'vulnerability.affectedProducts',
                'affectedProducts',
            );
            queryBuilder.andWhere('affectedProducts.cpe = :cpe', {
                cpe: searchParams.cpe,
            });
            return await this.paginate(options, queryBuilder);
        }

        const to = moment(searchParams.publihedDate.toDate);
        const from = moment(searchParams.publihedDate.fromDate);
        const diffDays = to.diff(from, 'days');

        if (diffDays > 0) {
            queryBuilder.andWhere(
                'vulnerability.createdDate BETWEEN :start AND :end',
                {
                    start: searchParams.publihedDate.fromDate,
                    end: searchParams.publihedDate.toDate,
                },
            );
        }
        const conditions = this.cvssQueryHandler(searchParams.cvss);
        if (conditions.length) {
            queryBuilder.leftJoinAndSelect('vulnerability.cvssScores', 'cvss');
            queryBuilder.andWhere(`(${conditions.join(' OR ')})`);
            queryBuilder.orderBy('cvss.baseScore','ASC')
        }
        //console.log(searchParams.vdo.AttributeList)
        if (searchParams.vdo.AttributeList.length) {
            this.vdoQueryHandler(searchParams.vdo.AttributeList, queryBuilder);
        }

        return await this.paginate(options, queryBuilder);
    }

    cvssQueryHandler(cvss: string[]) {
        const conditions = [];
        cvss.forEach((score) => {
            switch (score) {
                case 'Low':
                    conditions.push(
                        '(cvss.baseScore >= 0 AND cvss.baseScore < 3)',
                    );
                    break;
                case 'Medium':
                    conditions.push(
                        '(cvss.baseScore >= 3 AND cvss.baseScore < 6)',
                    );
                    break;
                case 'High':
                    conditions.push(
                        '(cvss.baseScore >= 6 AND cvss.baseScore < 9)',
                    );
                    break;
                case 'Critical':
                    conditions.push(
                        '(cvss.baseScore >= 9 AND cvss.baseScore <= 10)',
                    );
                    break;
            }
        });
        return conditions;
    }

    vdoQueryHandler(
        vdo: any[],
        queryBuilder: SelectQueryBuilder<Vulnerability>,
    ) {
        queryBuilder.leftJoin(
            'vulnerability.vdoCharacteristics',
            'vdoCharacteristics',
        );
        queryBuilder.andWhere(
            new Brackets((qb) => {
                vdo.forEach((attribute, index) => {
                    if (index === 0) {
                        qb.where(
                            `vdoCharacteristics.vdoNounGroup = :key${index} AND vdoCharacteristics.vdoLabel IN (:values${index})`,
                            {
                                [`key${index}`]: attribute.key,
                                [`values${index}`]: attribute.values,
                            },
                        );
                    } else {
                        qb.orWhere(
                            `vdoCharacteristics.vdoNounGroup = :key${index} And vdoCharacteristics.vdoLabel IN (:values${index})`,
                            {
                                [`key${index}`]: attribute.key,
                                [`values${index}`]: attribute.values,
                            },
                        );
                    }
                });
            }),
        );
    }

    vdoHandeler(vdo: any[], queryBuilder: SelectQueryBuilder<Vulnerability>) {
        queryBuilder.leftJoin(
            'vulnerability.vdoCharacteristics',
            'vdoCharacteristics',
        );

        const allValues = vdo.flatMap((attribute) => attribute.values);

        queryBuilder
            .andWhere('vdoCharacteristics.vdoLabel IN (:...labels)', {
                labels: allValues,
            })
            .groupBy('vulnerability.cveId')
            .having('COUNT(DISTINCT vdoCharacteristics.vdoLabel) >= :count', {
                count: allValues.length,
            });
    }
}
