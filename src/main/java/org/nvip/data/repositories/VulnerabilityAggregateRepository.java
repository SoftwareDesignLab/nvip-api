/**
 * Copyright 2023 Rochester Institute of Technology (RIT). Developed with
 * government support under contract 70RSAT19CB0000020 awarded by the United
 * States Department of Homeland Security.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
package org.nvip.data.repositories;

import jakarta.persistence.EntityManager;
import jakarta.persistence.PersistenceContext;
import jakarta.persistence.Query;
import jakarta.persistence.Tuple;
import jakarta.persistence.criteria.*;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.nvip.data.DBConnect;
import org.nvip.entities.*;
import org.nvip.util.VulnerabilityUtil;
import org.springframework.stereotype.Service;

import java.sql.SQLException;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.*;

@Service
public class VulnerabilityAggregateRepository {
	private static String dbType = DBConnect.getDatabaseType();
	private static final Logger logger = LogManager.getLogger(VulnerabilityAggregateRepository.class);

	@PersistenceContext EntityManager entityManager;
	VulnerabilityUtil vulnerabilityUtil;

	public VulnerabilityAggregateRepository(EntityManager entityManager, VulnerabilityUtil vulnerabilityUtil){
		this.entityManager = entityManager;
		this.vulnerabilityUtil = vulnerabilityUtil;
	}
	
	/**
	 * Calls a SP that returns a single vulnerability indentified by a single
	 * vulnerability id
	 * 
	 * @param vulnId Vulnerability id that is used to retrieve the vulnerability
	 * @return A single vulnerability entity
	 */
	public Vulnerability getVulnerability(int vulnId) {
		HashMap<Integer, List<Vulnerability>> searchResultMap = new HashMap<Integer, List<Vulnerability>>();
		Query query = entityManager.createNativeQuery(
			"""
          	SELECT
          		v.vuln_id,
          		v.cve_id,
          		v.description,
          		v.platform,
          		v.published_date,
          		v.last_modified_date,
				MAX(pc.commit_date) AS fixed_date,
				pc.commit_url,
				pc.commit_date,
				v.exists_at_nvd,
				v.exists_at_mitre,
				v.vdo_labels,
				v.vdo_label_confidences,
				v.vdo_noun_groups,
				v.urls,
				v.base_severities,
				v.severity_confidences,
				v.impact_scores,
				v.impact_confidences,
				v.product_id,
				v.cpe,
				v.domain,
				v.version,
				v.exploit_publish_date,
				v.exploit_url,
				ps.source_url
			FROM vulnerabilityaggregate v
			LEFT JOIN patchsourceurl ps ON v.vuln_id = ps.vuln_id
			LEFT JOIN patchcommit pc ON ps.source_url_id = pc.source_id
			WHERE v.vuln_id = ?
			GROUP BY
				v.cve_id,
				v.description,
				v.platform,
				v.published_date,
				v.last_modified_date,
				v.exists_at_nvd,
				v.exists_at_mitre,
				v.vdo_labels,
				v.vdo_label_confidences,
				v.vdo_noun_groups,
				v.urls,
				v.base_severities,
				v.severity_confidences,
				v.impact_scores,
				v.impact_confidences,
				v.product_id,
				v.cpe,
				v.domain,
				v.version,
				v.exploit_publish_date,
				v.exploit_url,
				fixed_date,
				pc.commit_url,
				pc.commit_date,
				ps.source_url
			ORDER BY pc.commit_date DESC
			LIMIT 1"""
		).setParameter(1, vulnId);

		Vulnerability vulnerability = null;
		try {
			Tuple result = (Tuple) query.getSingleResult();
			vulnerability = new Vulnerability(
					vulnId,
					result.get("cve_id", String.class),
					result.get("description", String.class),
					result.get("platform", String.class),
					LocalDateTime.parse(result.get("published_date", String.class)),
					LocalDateTime.parse(result.get("last_modified_date", String.class)),
					result.get("exists_at_mitre", Boolean.class),
					result.get("exists_at_nvd", Boolean.class)
			);

			VdoCharacteristic[] vdoList = VulnerabilityUtil.parseVDOList(
					result.get("cve_id", String.class),
					result.get("vdo_labels", String.class),
					result.get("vdo_label_confidences", String.class),
					result.get("vdo_noun_groups", String.class)
			);
			vulnerability.setVdoList(vdoList);

			CvssScore[] cvssScoreList = vulnerabilityUtil.parseCvssScoreList(
					result.get("cve_id", String.class),
					result.get("base_severity", String.class),
					result.get("severity_confidence", String.class),
					result.get("impact_score", String.class),
					result.get("impact_confidence", String.class)
			);
			vulnerability.setCvssScoreList(cvssScoreList);

			Product[] products = VulnerabilityUtil.parseProductList(
					result.get("product_id", String.class),
					result.get("cpe", String.class),
					result.get("domain", String.class),
					result.get("version", String.class)
			);
			vulnerability.setProducts(products);
		} catch (Exception e){
			logger.debug("CVE not Found");
			logger.warn(e);
		}

		return vulnerability;

	}

	/**
	 * Retrieves the vulnerabilities that have been updated within a given number of
	 * days from the current date.
	 * 
	 * @param dateRange Number of days before the current date that vulnerabilities
	 *                  will be gathered from
	 * @return Map of vulnerabilities mapped by the date associated with the when
	 *         the vulnerability was updated and the list of vulnerabilities that
	 *         were updated at that date
	 */
	public static Map<LocalDate, List<Vulnerability>> getDailyVulnerabilities(int dateRange) {

		String query = "select * from vulnerabilityaggregate WHERE run_date_time BETWEEN ? AND ? ORDER BY exists_at_nvd ASC;";
//		try (Connection conn = DBConnect.getConnection(); PreparedStatement stmt = conn.prepareStatement(query);) {
//			// Get the CVEs for the last 3 days from 2 days ago to today (inclusive)
//			LocalDateTime today = LocalDateTime.of(LocalDate.now(), LocalTime.MIDNIGHT).plusDays(1);
//
//			stmt.setTimestamp(1, Timestamp.valueOf(today.minusDays(dateRange)));
//			stmt.setTimestamp(2, Timestamp.valueOf(today));
//
//			Timestamp fixedDate = null;
//			String[] sources = {};
//			VdoCharacteristic[] vdoList = {};
//			CvssScore[] cvssScoreList = null;
//			Map<LocalDate, List<Vulnerability>> dailyVulns = new LinkedHashMap<>();
//			//Product product = null;
//			Product[] products = null;
//
//			// Populate the dailyVulns map with an empty list of vulns for each day of the
//			// search
//			for (int days = dateRange; days > 0; days--)
//				dailyVulns.put(today.minusDays(days).toLocalDate(), new ArrayList<>());
//
//			ResultSet rs = stmt.executeQuery();
//			while (rs.next()) {
//				try {
//					if (dailyVulns.get(rs.getTimestamp("run_date_time").toLocalDateTime().toLocalDate()) == null)
//						continue;
//
//					fixedDate = rs.getTimestamp("fixed_date");
//					vdoList = VulnerabilityUtil.parseVDOList(rs.getString("cve_id"), rs.getString("vdo_labels"), rs.getString("vdo_label_confidences"), rs.getString("vdo_noun_groups"));
//					cvssScoreList = Vu
//
//					lnerabilityUtil.parseCvssScoreList(rs.getString("cve_id"), rs.getString("base_severities"), rs.getString("severity_confidences"), rs.getString("impact_scores"),
//							rs.getString("impact_confidences"));
//
//					products = VulnerabilityUtil.parseProductList(rs.getString("product_id"), rs.getString("cpe"), rs.getString("domain"), rs.getString("version"));
//					// product = new Product(rs.getInt("product_id"), rs.getString("cpe"),
//					// rs.getString("domain"), null, rs.getString("version"));
//
//					dailyVulns.get(rs.getTimestamp("run_date_time").toLocalDateTime().toLocalDate())
//							.add(new Vulnerability(rs.getInt("vuln_id"), rs.getString("cve_id"), rs.getString("description"), rs.getString("platform"), rs.getString("published_date"),
//									rs.getString("last_modified_date"), (fixedDate == null ? null : fixedDate.toLocalDateTime()), rs.getBoolean("exists_at_mitre"), rs.getBoolean("exists_at_nvd"),
//									sources, vdoList, cvssScoreList, products));
//				} catch (Exception e) {
//					e.printStackTrace();
//					logger.error(e.getMessage());
//				}
//			}
//			return dailyVulns;
//		} catch (SQLException e) {
//			logger.error(e.getMessage());
//		}

		return null;
	}
}