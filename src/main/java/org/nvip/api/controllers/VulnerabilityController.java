/**
 * Copyright 2023 Rochester Institute of Technology (RIT). Developed with
 * government support under contract 70RSAT19CB0000020 awarded by the United
 * States Department of Homeland Security.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
package org.nvip.api.controllers;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.nvip.api.serializers.*;
import org.nvip.data.repositories.VulnerabilityAggregateRepository;
import org.nvip.data.repositories.VulnerabilityRepository;
import org.nvip.entities.*;
import org.nvip.util.VulnerabilityUtil;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/vulnerabilities")
public class VulnerabilityController {

	private static final Logger logger = LogManager.getLogger(VulnerabilityController.class);


	final VulnerabilityRepository vulnerabilityRepository;
	final VulnerabilityAggregateRepository vulnerabilityAggregateRepository;

	@Autowired VulnerabilityUtil vulnerabilityUtil;

	public VulnerabilityController(VulnerabilityRepository vulnerabilityRepository, VulnerabilityAggregateRepository vulnerabilityAggregateRepository) {
		this.vulnerabilityRepository = vulnerabilityRepository;
		this.vulnerabilityAggregateRepository = vulnerabilityAggregateRepository;
	}

	@GetMapping
	public List<VulnerabilitySummaryDTO> getVulnerabilities(
			@RequestParam(value="startDate", required = false) @DateTimeFormat(iso=DateTimeFormat.ISO.DATE) LocalDate startDate,
			@RequestParam(value="endDate", required = false) @DateTimeFormat(iso=DateTimeFormat.ISO.DATE) LocalDate endDate,
			@RequestParam(value="cvssScore", required = false) String[] cvssScores,
			@RequestParam(value="vdoLabels", required = false) String[] vdoLabels,
			@RequestParam(value="product", required = false) String product,
			@RequestParam(value="keyword", required = false) String keyword,
			@RequestParam(value="limitCount", required = false, defaultValue="100") Integer limitCount
	) {

		//TODO: Spring Security
		//		String userName = req.getParameter("username");
		//		String token = req.getParameter("token");
		//
		//		if (userName == null || token == null)
		//			ServletUtil.setResponse(resp, 401, "Unauthorized user!");
		//
		//		User user = UserDAO.getRoleIDandExpirationDate(userName, token);
		//
		//		if (user == null)
		//			ServletUtil.setResponse(resp, 401, "Unauthorized user!");

		LocalDateTime startDateParam = (startDate == null) ? null : LocalDateTime.of(startDate, LocalTime.now());
		LocalDateTime endDateParam = (endDate == null) ? null : LocalDateTime.of(endDate, LocalTime.now());

		List<Vulnerability> searchResults = vulnerabilityRepository.searchVulnerability(
				keyword,
				startDateParam,
				endDateParam,
				cvssScores,
				vdoLabels,
				limitCount,
				product);

		logger.info("SEARCH RESULT SIZE: {}", searchResults.size());

		DateTimeFormatter dateFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd");
		DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");

		return searchResults.stream()
				.map(v -> {
					VulnerabilitySummaryDTO.VulnerabilitySummaryDTOBuilder builder = VulnerabilitySummaryDTO.builder();
					builder.vulnId(v.getVulnId())
							.cveId(v.getCveId())
							.description(v.getDescription())
							// .existInMitre(v.isExistInMitre())
							// .existInNvd(v.isExistInNvd())
							.type(parseType(v.getVdoCharacteristics()));

					if(v.getPublishedDate() != null){
						builder.publishedDate(v.getPublishedDate().format(dateTimeFormatter));
					} else builder.publishedDate("N/A");

					if(v.getLastModifiedDate() != null){
						builder.lastModifiedDate(v.getLastModifiedDate().format(dateTimeFormatter));
					} else builder.lastModifiedDate("N/A");

					if(v.getCreatedDate() != null){
						builder.createdDate(v.getCreatedDate().format(dateFormatter));
					} // else builder.fixedDate("N/A");

					for(VdoCharacteristic characteristic: v.getVdoCharacteristics()){
						builder.vdo(VdoCharacteristicDTO.builder()
								.cveId(v.getCveId())
								.vdoLabel(characteristic.getVdoLabel())
								.vdoConfidence(characteristic.getVdoConfidence())
								.vdoNounGroup(characteristic.getVdoNounGroup())
								.build());
					}
					builder.type(parseType(v.getVdoCharacteristics()));

					List<String> cpes = new ArrayList<>();
					for(AffectedProduct release: v.getAffectedProducts()){
						cpes.add(release.getCpe());
					}
					builder.domain(parseDomain(cpes));

					return builder.build();
				})
				.toList();
	}

	private String parseType(List<VdoCharacteristic> vdoCharacteristics){
		String type = vdoCharacteristics.stream()
				.filter(x -> x.getVdoNounGroup().contains("ImpactMethod"))
				.map(x -> x.getVdoNounGroup())
				.distinct()
				.collect(Collectors.joining(", "));
		return type.isEmpty() ? "N/A" : type;
	}

	// private String parseDiscoveredBy(List<VulnerabilitySourceUrl> sources) {
	// 	String discoveredBy = "N/A";
	// 	if (sources != null && sources.size() > 0) {
	// 		String url = sources.get(sources.size() - 1).getUrl();
	// 		String domain1 = VulnerabilityUtil.getDomainName(url);
	// 		if (sources.size() > 1) {
	// 			url = sources.get(sources.size() - 2).getUrl();
	// 			String domain2 = VulnerabilityUtil.getDomainName(url);
	// 			discoveredBy = domain1 + ", " + domain2;
	// 		} else
	// 			discoveredBy = domain1;
	// 	}
	// 	return discoveredBy;
	// }

	private String parseDomain(List<String> cpes) {
		String domain = "N/A";
		if (cpes != null && cpes.size() > 0) {
			domain = VulnerabilityUtil.getCompanyProduct(cpes.get(0));
		}
		return domain;
	}

	@GetMapping(value="/{id}")
	public VulnerabilitySearchDTO getVulnerability(@PathVariable(value = "id") String cveId){
		DateTimeFormatter dateFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd");
		DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");

		Vulnerability vulnerability = vulnerabilityRepository.getByCveId(cveId);

		VulnerabilitySearchDTO.VulnerabilitySearchDTOBuilder builder = VulnerabilitySearchDTO.builder();
		builder.vulnId(vulnerability.getVulnId())
				.cveId(vulnerability.getCveId())
				.description(vulnerability.getDescription())
				// .patch(vulnerability.getPatch())
				// .existInMitre(vulnerability.isExistInMitre())
				// .existInNvd(vulnerability.isExistInNvd())
				// .timeGapMitre(vulnerability.getTimeGapMitre())
				// .timeGapNvd(vulnerability.getTimeGapNvd())
				.type(parseType(vulnerability.getVdoCharacteristics()));
				// .discoveredBy(parseDiscoveredBy(vulnerability.getSourceUrls()));

		// if(vulnerability.getIntroducedDate() != null){
		// 	builder.introducedDate(vulnerability.getIntroducedDate().format(dateTimeFormatter));
		// } else builder.introducedDate("N/A");

		if(vulnerability.getPublishedDate() != null){
			builder.publishedDate(vulnerability.getPublishedDate().format(dateTimeFormatter));
		} else builder.publishedDate("N/A");

		if(vulnerability.getCreatedDate() != null){
			builder.createdDate(vulnerability.getCreatedDate().format(dateTimeFormatter));
		} else builder.createdDate("N/A");

		if(vulnerability.getLastModifiedDate() != null){
			builder.lastModifiedDate(vulnerability.getLastModifiedDate().format(dateTimeFormatter));
		} else builder.lastModifiedDate("N/A");

		// if(vulnerability.getFixedDate() != null){
		// 	builder.fixedDate(vulnerability.getFixedDate().format(dateFormatter));
		// } else builder.fixedDate("N/A");

		for(VdoCharacteristic characteristic: vulnerability.getVdoCharacteristics()){
			builder.characteristic(VdoCharacteristicDTO.builder()
					.cveId(vulnerability.getCveId())
					.vdoLabel(characteristic.getVdoLabel())
					.vdoConfidence(characteristic.getVdoConfidence())
					.vdoNounGroup(characteristic.getVdoNounGroup())
					.build());
		}

		List<String> cpes = new ArrayList<>();
		for(AffectedProduct product: vulnerability.getAffectedProducts()){
			builder.product(ProductDTO.builder()
					.productName(product.getProductName())
					.cpe(product.getCpe())
					.version(product.getVersion())
					.build()
			);
			builder.cpe(product.getCpe());
			cpes.add(product.getCpe());
		}
		builder.domain(parseDomain(cpes));

		for(Cvss cvss: vulnerability.getCvssScores()){
			builder.cvss(CvssDTO.builder()
					.cveId(vulnerability.getCveId())
					.baseScore(cvss.getBaseScore())
					.impactScore(cvss.getImpactScore())
					.build()
			);
		}

		// for(VulnerabilitySourceUrl url: vulnerability.getSourceUrls()){
		// 	builder.source(url.getUrl());
		// }

		return builder.build();
	}

	private VulnerabilitySummaryDTO mapVuln(VulnerabilityAggregate vuln) {
		DateTimeFormatter dateFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd");
		DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
		VulnerabilitySummaryDTO.VulnerabilitySummaryDTOBuilder builder = VulnerabilitySummaryDTO.builder();
		builder.vulnId(vuln.getVulnId())
				.cveId(vuln.getCveId())
				.description(vuln.getDescription().length() < 297 ? vuln.getDescription() : vuln.getDescription().substring(0, 297)+"...")
				.platform(vuln.getPlatform())
				.publishedDate(
						vuln.getPublishedDate() != null ? vuln.getPublishedDate().format(dateTimeFormatter) : "N/A"
				)
				.lastModifiedDate(
						vuln.getLastModifiedDate() != null ? vuln.getLastModifiedDate().format(dateTimeFormatter) : "N/A")
				.fixedDate(
						vuln.getFixedDate() != null ? vuln.getFixedDate().format(dateTimeFormatter) : "N/A"
				)
				.runDateTime(vuln.getRunDateTime().format(dateFormatter))
				.existInNvd(vuln.isExistInNvd())
				.existInMitre(vuln.isExistInMitre())
				.domain(vuln.getDomain())
				.version(vuln.getVersion());

		List<VdoCharacteristic> characteristics = List.of(VulnerabilityUtil.parseVDOList(vuln.getCveId(), vuln.getVdoLabels(), vuln.getVdoLabelConfidences(), vuln.getVdoNounGroups()));
		for(VdoCharacteristic characteristic: characteristics){
			builder.vdo(
					VdoCharacteristicDTO.builder()
							.cveId(characteristic.getCveId())
							.vdoLabel(characteristic.getVdoLabel())
							.vdoConfidence(characteristic.getVdoConfidence())
							.vdoNounGroup(characteristic.getVdoNounGroup())
							.build());
		}
		builder.type(parseType(characteristics));

		return builder.build();
	}

	@GetMapping(value = "/daily", produces = "application/json")
	public Map<LocalDate, List<VulnerabilitySummaryDTO>> getDailyVulnerabilities(@RequestParam Integer dateRange) {
		Map<LocalDate, List<VulnerabilityAggregate>> dailyVulns = vulnerabilityAggregateRepository.getDailyVulnerabilities(dateRange);
		return dailyVulns.entrySet()
				.stream()
				.collect(Collectors.toMap(
					e -> e.getKey(),
					e -> e.getValue().stream()
							.filter(this::removeLowQualityCve)
							.sorted(
									Comparator.comparing(VulnerabilityAggregate::isExistInNvd)
											.thenComparing(VulnerabilityAggregate::getCveId, Comparator.reverseOrder())
							)
							.map(vuln -> {
								VulnerabilitySummaryDTO.VulnerabilitySummaryDTOBuilder builder = VulnerabilitySummaryDTO.builder();
								builder.vulnId(vuln.getVulnId())
										.cveId(vuln.getCveId())
										.description(vuln.getDescription().length() < 297 ? vuln.getDescription() : vuln.getDescription().substring(0, 297)+"...")
										.publishedDate(
												vuln.getPublishedDate() != null ? vuln.getPublishedDate().format(dateTimeFormatter) : "N/A"
										)
										.lastModifiedDate(
												vuln.getLastModifiedDate() != null ? vuln.getLastModifiedDate().format(dateTimeFormatter) : "N/A")
										.fixedDate(
												vuln.getFixedDate() != null ? vuln.getFixedDate().format(dateTimeFormatter) : "N/A"
										)
										.createdDate(vuln.getCreatedDate().format(dateFormatter))
										.existInNvd(vuln.isExistInNvd())
										.existInMitre(vuln.isExistInMitre());
								List<VdoCharacteristic> characteristics = List.of(vulnerabilityUtil.parseVDOList(vuln.getCveId(), vuln.getVdoLabels(), vuln.getVdoLabelConfidences(), vuln.getVdoNounGroups()));
								for(VdoCharacteristic characteristic: characteristics){
									builder.vdo(
										VdoCharacteristicDTO.builder()
										.cveId(characteristic.getVulnerability().getCveId())
										.vdoLabel(characteristic.getVdoLabel())
										.vdoConfidence(characteristic.getVdoConfidence())
										.vdoNounGroup(characteristic.getVdoNounGroup())
										.build());
								}
								builder.type(parseType(characteristics));

								return builder.build();
							})
							.toList()
				));
	}

	@GetMapping(value = "/dailyPage", produces = "application/json")
	public List<VulnerabilitySummaryDTO> getDailyVulnerabilitiesByDate(@RequestParam String date, @RequestParam Integer pageNum, @RequestParam Integer pageSize) {
		List<VulnerabilityAggregate> dailyVulns = vulnerabilityAggregateRepository.getVulnerabilitiesByDate(date, pageNum, pageSize);
		return dailyVulns.stream().map(this::mapVuln).toList();
	}

	@GetMapping(value = "/dailyPageCount", produces = "application/json")
	public Object getVulnerabilitiesCount(@RequestParam Integer dateRange) {
		return vulnerabilityAggregateRepository.getVulnCountRange(dateRange);
	}

	private boolean removeLowQualityCve(VulnerabilityAggregate vuln) {
		String pattern = "\\bCVE-20\\d{2}-\\d{4,5}\\b";

		Pattern p = Pattern.compile(pattern);
		Matcher m = p.matcher(vuln.getDescription());;

		int patternLength = 0;

		while (m.find())
			patternLength += m.group().length();

		return !(patternLength >= vuln.getDescription().length() * 0.9);
	}
}