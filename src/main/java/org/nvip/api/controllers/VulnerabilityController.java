/**
 * Copyright 2023 Rochester Institute of Technology (RIT). Developed with
 * government support under contract 70RSAT19CB0000020 awarded by the United
 * States Department of Homeland Security.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
package org.nvip.api.controllers;

import lombok.RequiredArgsConstructor;
import org.nvip.api.serializers.*;
import org.nvip.api.services.VulnService;
import org.nvip.data.repositories.VulnRepository;
import org.nvip.data.repositories.VulnerabilityRepository;
import org.nvip.entities.*;
import org.nvip.util.CvssGenUtil;
import org.nvip.util.VulnerabilityUtil;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/vulnerabilities")
@RequiredArgsConstructor
public class VulnerabilityController {

	final VulnerabilityRepository vulnerabilityRepository;
	final VulnService vulnService;
	final VulnRepository vulnRepository;

	@Autowired VulnerabilityUtil vulnerabilityUtil;
	@Autowired CvssGenUtil cvssGenUtil;

	@GetMapping
	public List<VulnerabilitySummaryDTO> getVulnerabilities(
			@RequestParam(value="startDate", required = false) @DateTimeFormat(iso=DateTimeFormat.ISO.DATE) LocalDate startDate,
			@RequestParam(value="endDate", required = false) @DateTimeFormat(iso=DateTimeFormat.ISO.DATE) LocalDate endDate,
			@RequestParam(value="cvssScores", required = false) int[] cvssScores,
			@RequestParam(value="vdoLabels", required = false) String[] vdoLabels,
			@RequestParam(value="product", required = false) String product,
			@RequestParam(value="keyword", required = false) String keyword,
			@RequestParam(value="limitCount", required = false, defaultValue="100") Integer limitCount
	) {

		//TODO: Spring Security
		//		String userName = req.getParameter("username");
		//		String token = req.getParameter("token");
		//
		//		if (userName == null || token == null)
		//			ServletUtil.setResponse(resp, 401, "Unauthorized user!");
		//
		//		User user = UserDAO.getRoleIDandExpirationDate(userName, token);
		//
		//		if (user == null)
		//			ServletUtil.setResponse(resp, 401, "Unauthorized user!");

		LocalDateTime startDateParam = (startDate == null) ? null : LocalDateTime.of(startDate, LocalTime.now());
		LocalDateTime endDateParam = (endDate == null) ? null : LocalDateTime.of(endDate, LocalTime.now());

		List<Vulnerability> searchResults = vulnerabilityRepository.searchVulnerability(
				keyword,
				startDateParam,
				endDateParam,
				cvssScores,
				vdoLabels,
				limitCount,
				product);

		DateTimeFormatter dateFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd");
		DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");

		return searchResults.stream()
				.map(v -> {
					VulnerabilitySummaryDTO.VulnerabilitySummaryDTOBuilder builder = VulnerabilitySummaryDTO.builder();

					Description desc = v.getDescription();

					builder.vulnId(v.getVulnId())
							.cveId(v.getCveId())
							.description(desc.getDescription())
							.existInMitre(v.existsInMitre())
							.existInNvd(v.existsInNvd())
							.type(vulnService.parseType(v.getVdoCharacteristics()));

					// if description is system generated, try to find a user generated altDesc
					// if description is user generated, definitely find the most recent system generated altDesc
					Description altDescription = vulnerabilityUtil.getAltDescription(v.getDescription());
					if (altDescription == null) // case where there's no user desc
						builder.description(v.getDescriptionString());
					else if (altDescription.getIsUserGenerated() == 1) { // case where user desc exists, this should trump system desc
						builder.description(altDescription.getDescription());
						builder.altDescription(DescriptionDTO.builder()
								.description(v.getDescriptionString())
								.createdDate(v.getDescription().getCreatedDate().format(dateFormatter))
								.isUserGenerated(v.getDescription().getIsUserGenerated())
								.build());
					}
					else { // case where alt desc is system generated, main desc is user generated, no need to switch anything
						builder.description(v.getDescriptionString());
						builder.altDescription(DescriptionDTO.builder()
								.description(altDescription.getDescription())
								.createdDate(altDescription.getCreatedDate().format(dateFormatter))
								.isUserGenerated(altDescription.getIsUserGenerated())
								.build());
					}

					if(v.getPublishedDate() != null){
						builder.publishedDate(v.getPublishedDate().format(dateTimeFormatter));
					} else builder.publishedDate("N/A");

					if(v.getLastModifiedDate() != null){
						builder.lastModifiedDate(v.getLastModifiedDate().format(dateTimeFormatter));
					} else builder.lastModifiedDate("N/A");

					if(v.getCreatedDate() != null){
						builder.createdDate(v.getCreatedDate().format(dateFormatter));
					}

					for(VdoCharacteristic characteristic: v.getVdoCharacteristics()){
						builder.vdo(VdoCharacteristicDTO.builder()
								.cveId(v.getCveId())
								.vdoLabel(characteristic.getVdoLabel())
								.vdoConfidence(characteristic.getVdoConfidence())
								.vdoNounGroup(characteristic.getVdoNounGroup())
								.build());
					}
					builder.type(vulnService.parseType(v.getVdoCharacteristics()));

					List<String> cpes = new ArrayList<>();
					for(AffectedProduct release: v.getAffectedProducts()){
						cpes.add(release.getCpe());
					}
					builder.domain(vulnService.parseDomain(cpes));

					return builder.build();
				})
				.toList();
	}

	@GetMapping(value = "/date/{createdDate}")
	public List<VulnerabilitySearchDTO> getVulnCreatedDate(@PathVariable(value="createdDate", required = true) @DateTimeFormat(iso=DateTimeFormat.ISO.DATE) LocalDate createdDate) {
		DateTimeFormatter dateFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd");
		DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");

		List<Vulnerability> vulnerabilities = vulnerabilityRepository.getByCreatedDate(createdDate.atStartOfDay());

		return vulnerabilities.stream()
				.map(v -> {
					VulnerabilitySearchDTO.VulnerabilitySearchDTOBuilder builder = VulnerabilitySearchDTO.builder();

					Description desc = v.getDescription();

					builder.vulnId(v.getVulnId())
							.cveId(v.getCveId())
							.description(desc.getDescription())
							.existInMitre(v.existsInMitre())
							.existInNvd(v.existsInNvd())
							.type(vulnService.parseType(v.getVdoCharacteristics()));

//					Description altDescription = vulnerabilityUtil.getAltDescription(desc);
//					builder.altDescription(DescriptionDTO.builder()
//							.description(altDescription.getDescription())
//							.isUserGenerated(altDescription.getIsUserGenerated())
//							.build());

					if(v.getPublishedDate() != null){
						builder.publishedDate(v.getPublishedDate().format(dateTimeFormatter));
					} else builder.publishedDate("N/A");

					if(v.getLastModifiedDate() != null){
						builder.lastModifiedDate(v.getLastModifiedDate().format(dateTimeFormatter));
					} else builder.lastModifiedDate("N/A");

					if(v.getCreatedDate() != null){
						builder.createdDate(v.getCreatedDate().format(dateFormatter));
					}

					List<VdoCharacteristic> characteristics = v.getVdoCharacteristics();
					// filter VDO labels by vdoLabel, max by createdDate
					characteristics = characteristics.stream()
							.collect(Collectors.groupingBy(VdoCharacteristic::getVdoLabel))
							.values()
							.stream()
							.map(x -> x.stream().max(Comparator.comparing(VdoCharacteristic::getCreatedDate)).get())
							.collect(Collectors.toList());

					for(VdoCharacteristic characteristic: characteristics){
						builder.characteristic(VdoCharacteristicDTO.builder()
								.cveId(v.getCveId())
								.vdoLabel(characteristic.getVdoLabel())
								.vdoConfidence(characteristic.getVdoConfidence())
								.vdoNounGroup(characteristic.getVdoNounGroup())
								.userId(characteristic.getUserId())
								.isActive(characteristic.getIsActive())
								.build());
					}



					for(RawDescription rawDesc: v.getRawDescriptions()){
						builder.source(
								RawDescriptionDTO.builder()
										.cveId(v.getCveId())
										.rawDescription(rawDesc.getRawDescription())
										.createdDate(String.valueOf(rawDesc.getCreatedDate()))
										.publishedDate(String.valueOf(rawDesc.getPublishedDate()))
										.lastModifiedDate(String.valueOf(rawDesc.getLastModifiedDate()))
										.sourceUrl(rawDesc.getSourceUrl())
										.isGarbage(rawDesc.getIsGarbage())
										.sourceType(rawDesc.getSourceType())
										.parserType(rawDesc.getParserType())
										.build()
						);
					}

					List<String> cpes = new ArrayList<>();
					for(AffectedProduct release: v.getAffectedProducts()){
						cpes.add(release.getCpe());
					}
					builder.domain(vulnService.parseDomain(cpes));

					return builder.build();
				})
				.toList();
	}

	@GetMapping(value="/{id}")
	public VulnerabilitySearchDTO getVulnerability(@PathVariable(value = "id") String cveId) {
		DateTimeFormatter dateFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd");
		DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");

		Vulnerability vulnerability = vulnRepository.findByCveId(cveId);

		VulnerabilitySearchDTO.VulnerabilitySearchDTOBuilder builder = VulnerabilitySearchDTO.builder();
		builder.vulnId(vulnerability.getVulnId())
				.cveId(vulnerability.getCveId())
				.description(vulnerability.getDescription().getDescription())
				.existInMitre(vulnerability.existsInMitre())
				.existInNvd(vulnerability.existsInNvd())
				.type(vulnService.parseType(vulnerability.getVdoCharacteristics()));

		// if description is system generated, try to find a user generated altDesc
		// if description is user generated, definitely find the most recent system generated altDesc
		Description altDescription = vulnerabilityUtil.getAltDescription(vulnerability.getDescription());
		if (altDescription == null) // case where there's no user desc
			builder.description(vulnerability.getDescriptionString());
		else if (altDescription.getIsUserGenerated() == 1) { // case where user desc exists, this should trump system desc
			builder.description(altDescription.getDescription());
			builder.altDescription(DescriptionDTO.builder()
					.description(vulnerability.getDescriptionString())
					.createdDate(vulnerability.getDescription().getCreatedDate().format(dateFormatter))
					.isUserGenerated(vulnerability.getDescription().getIsUserGenerated())
					.build());
		}
		else { // case where alt desc is system generated, main desc is user generated, no need to switch anything
			builder.description(vulnerability.getDescriptionString());
			builder.altDescription(DescriptionDTO.builder()
					.description(altDescription.getDescription())
					.createdDate(altDescription.getCreatedDate().format(dateFormatter))
					.isUserGenerated(altDescription.getIsUserGenerated())
			.build());
		}


		builder.introducedDate("N/A");

		if(vulnerability.getPublishedDate() != null){
			builder.publishedDate(vulnerability.getPublishedDate().format(dateTimeFormatter));
		} else builder.publishedDate("N/A");

		if(vulnerability.getCreatedDate() != null){
			builder.createdDate(vulnerability.getCreatedDate().format(dateTimeFormatter));
		} else builder.createdDate("N/A");

		if(vulnerability.getLastModifiedDate() != null){
			builder.lastModifiedDate(vulnerability.getLastModifiedDate().format(dateTimeFormatter));
		} else builder.lastModifiedDate("N/A");

		builder.fixedDate("N/A");

		List<VdoCharacteristic> characteristics = vulnerability.getVdoCharacteristics();
		// filter VDO labels by vdoLabel, max by createdDate
		characteristics = characteristics.stream()
				.collect(Collectors.groupingBy(VdoCharacteristic::getVdoLabel))
				.values()
				.stream()
				.map(x -> x.stream().max(Comparator.comparing(VdoCharacteristic::getCreatedDate)).get())
				.collect(Collectors.toList());

		for(VdoCharacteristic characteristic: characteristics){
			builder.characteristic(VdoCharacteristicDTO.builder()
					.cveId(vulnerability.getCveId())
					.vdoLabel(characteristic.getVdoLabel())
					.vdoConfidence(characteristic.getVdoConfidence())
					.vdoNounGroup(characteristic.getVdoNounGroup())
					.userId(characteristic.getUserId())
					.isActive(characteristic.getIsActive())
					.build());
		}

		List<String> cpes = new ArrayList<>();
		for(AffectedProduct product: vulnerability.getAffectedProducts()){
			builder.product(ProductDTO.builder()
					.productId(product.getAffectedProductId())
					.productName(product.getProductName())
					.cpe(product.getCpe())
					.version(product.getVersion())
					.build());
			builder.cpe(product.getCpe());
			cpes.add(product.getCpe());
		}
		builder.domain(vulnService.parseDomain(cpes));

//		if (vulnerability.getCvssScore() != null)
//			builder.cvssScore(CvssDTO.builder()
//					.cveId(vulnerability.getCveId())
//					.baseScore(vulnerability.getCvssScore().getBaseScore())
//					.build());

		//TODO: we dont need cve id in these objects

		for(RawDescription rawDesc: vulnerability.getRawDescriptions()){
			builder.source(
					RawDescriptionDTO.builder()
							.cveId(vulnerability.getCveId())
							.rawDescription(rawDesc.getRawDescription())
							.createdDate(String.valueOf(rawDesc.getCreatedDate()))
							.publishedDate(String.valueOf(rawDesc.getPublishedDate()))
							.lastModifiedDate(String.valueOf(rawDesc.getLastModifiedDate()))
							.sourceUrl(rawDesc.getSourceUrl())
							.isGarbage(rawDesc.getIsGarbage())
							.sourceType(rawDesc.getSourceType())
							.parserType(rawDesc.getParserType())
							.build()
			);
		}

		// TODO: this ultimately replaces all previous CVSS storing using a simple lookup
		// get rid of old CVSS table and code when ready
		// get rid of CVSS insertions
		Double calculatedCVSSScore = cvssGenUtil.calculateCVSSScore(characteristics);

		if (calculatedCVSSScore != null) {
			builder.cvssScore(CvssDTO.builder()
					.cveId(vulnerability.getCveId())
					.baseScore(calculatedCVSSScore)
					.build());

			for (PatchCommit patch : vulnerability.getPatchCommits()) {
				builder.patchCommit(
						PatchCommitDTO.builder()
								.cveId(vulnerability.getCveId())
								.sourceUrl(patch.getSourceUrl().getSourceUrl())
								.commitSha(patch.getCommitSha())
								.commitMessage(patch.getCommitMessage())
								.commitDate(String.valueOf(patch.getCommitDate()))
								.linesChanged(patch.getLinesChanged())
								.build()
				);
			}

			for (Fix fix : vulnerability.getFixes()) {
				builder.fix(
						FixDTO.builder()
								.cveId(vulnerability.getCveId())
								.sourceUrl(fix.getSourceUrl())
								.fixDescription(fix.getFixDescription())
								.build()
				);
			}

			for (Exploit exploit : vulnerability.getExploits()) {
				builder.exploit(
						ExploitDTO.builder()
								.cveId(vulnerability.getCveId())
								.source(exploit.getSource())
								.sourceUrl(exploit.getSourceUrl())
								.description(exploit.getDescription())
								.dateCreated(String.valueOf(exploit.getDateCreated()))
								.datePublished(String.valueOf(exploit.getDatePublished()))
								.isRepo(exploit.isRepo())
								.build()
				);
			}
		}

		return builder.build();
	}
}