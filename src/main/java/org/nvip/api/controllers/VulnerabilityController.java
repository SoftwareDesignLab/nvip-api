/**
 * Copyright 2023 Rochester Institute of Technology (RIT). Developed with
 * government support under contract 70RSAT19CB0000020 awarded by the United
 * States Department of Homeland Security.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
package org.nvip.api.controllers;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.nvip.api.serializers.*;
import org.nvip.data.repositories.VulnerabilityAggregateRepository;
import org.nvip.data.repositories.VulnerabilityRepository;
import org.nvip.entities.*;
import org.nvip.util.VulnerabilityUtil;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/vulnerabilities")
public class VulnerabilityController {

	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(VulnerabilityController.class);

	final VulnerabilityRepository vulnerabilityRepository;
	final VulnerabilityAggregateRepository vulnerabilityAggregateRepository;

	public VulnerabilityController(VulnerabilityRepository vulnerabilityRepository, VulnerabilityAggregateRepository vulnerabilityAggregateRepository) {
		this.vulnerabilityRepository = vulnerabilityRepository;
		this.vulnerabilityAggregateRepository = vulnerabilityAggregateRepository;
	}

	@GetMapping
	public List<VulnerabilitySummaryDTO> getVulnerabilities(
			@RequestParam(value="startDate", required = false) @DateTimeFormat(iso=DateTimeFormat.ISO.DATE_TIME) LocalDateTime startDate,
			@RequestParam(value="endDate", required = false) @DateTimeFormat(iso=DateTimeFormat.ISO.DATE_TIME) LocalDateTime endDate,
			@RequestParam(value="cvssScore", required = false) String[] cvssScores,
			@RequestParam(value="vdoLabels", required = false) String[] vdoLabels,
			@RequestParam(value="product", required = false) String product,
			@RequestParam(value="keyword", required = false) String keyword,
			@RequestParam(value="limitCount", required = false, defaultValue="100") Integer limitCount
	) {

		//TODO: Spring Security
		//		String userName = req.getParameter("username");
		//		String token = req.getParameter("token");
		//
		//		if (userName == null || token == null)
		//			ServletUtil.setResponse(resp, 401, "Unauthorized user!");
		//
		//		User user = UserDAO.getRoleIDandExpirationDate(userName, token);
		//
		//		if (user == null)
		//			ServletUtil.setResponse(resp, 401, "Unauthorized user!");

		List<Vulnerability> searchResults = vulnerabilityRepository.searchVulnerability(
				keyword,
				startDate,
				endDate,
				cvssScores,
				vdoLabels,
				limitCount,
				product);

		DateTimeFormatter dateFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd");
		DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");

		return searchResults.stream()
				.map(v -> {
					VulnerabilitySummaryDTO.VulnerabilitySummaryDTOBuilder builder = VulnerabilitySummaryDTO.builder();
					builder.vulnId(v.getVulnId())
							.cveId(v.getCveId())
							.description(v.getDescription())
							.existInMitre(v.isExistInMitre())
							.existInNvd(v.isExistInNvd())
							.type(parseType(v.getVdoCharacteristics()));

					if(v.getPublishedDate() != null){
						builder.publishedDate(v.getPublishedDate().format(dateTimeFormatter));
					} else builder.publishedDate("N/A");

					if(v.getLastModifiedDate() != null){
						builder.lastModifiedDate(v.getLastModifiedDate().format(dateTimeFormatter));
					} else builder.lastModifiedDate("N/A");

					if(v.getFixedDate() != null){
						builder.fixedDate(v.getFixedDate().format(dateFormatter));
					} else builder.fixedDate("N/A");

					for(VdoCharacteristic characteristic: v.getVdoCharacteristics()){
						builder.vdo(VdoCharacteristicDTO.builder()
								.cveId(v.getCveId())
								.vdoLabel(characteristic.getVdoLabels().getVdoLabelName())
								.vdoConfidence(characteristic.getVdoConfidence())
								.vdoNounGroup(characteristic.getVdoGroup().getVdoGroupName())
								.build());
					}
					builder.type(parseType(v.getVdoCharacteristics()));

					List<String> cpes = new ArrayList<>();
					for(AffectedRelease release: v.getAffectedReleases()){
						cpes.add(release.getProduct().getCpe());
					}
					builder.domain(parseDomain(cpes));

					return builder.build();
				})
				.toList();
	}

	private String parseType(List<VdoCharacteristic> vdoCharacteristics){
		String type = vdoCharacteristics.stream()
				.filter(x -> x.getVdoGroup().getVdoGroupName().contains("ImpactMethod"))
				.map(x -> x.getVdoGroup().getVdoGroupName())
				.distinct()
				.collect(Collectors.joining(", "));
		return type.isEmpty() ? "N/A" : type;
	}

	private String parseDiscoveredBy(List<VulnerabilitySourceUrl> sources) {
		String discoveredBy = "N/A";
		if (sources != null && sources.size() > 0) {
			String url = sources.get(sources.size() - 1).getUrl();
			String domain1 = VulnerabilityUtil.getDomainName(url);
			if (sources.size() > 1) {
				url = sources.get(sources.size() - 2).getUrl();
				String domain2 = VulnerabilityUtil.getDomainName(url);
				discoveredBy = domain1 + ", " + domain2;
			} else
				discoveredBy = domain1;
		}
		return discoveredBy;
	}

	private String parseDomain(List<String> cpes) {
		String domain = "N/A";
		if (cpes != null && cpes.size() > 0) {
			domain = VulnerabilityUtil.getCompanyProduct(cpes.get(0));
		}
		return domain;
	}

	@GetMapping(value="/{id}")
	public VulnerabilitySearchDTO getVulnerability(@PathVariable(value = "id") String cveId){
		DateTimeFormatter dateFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd");
		DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");

		Vulnerability vulnerability = vulnerabilityRepository.getByCveId(cveId);

		VulnerabilitySearchDTO.VulnerabilitySearchDTOBuilder builder = VulnerabilitySearchDTO.builder();
		builder.vulnId(vulnerability.getVulnId())
				.cveId(vulnerability.getCveId())
				.description(vulnerability.getDescription())
				.patch(vulnerability.getPatch())
				.existInMitre(vulnerability.isExistInMitre())
				.existInNvd(vulnerability.isExistInNvd())
				.timeGapMitre(vulnerability.getTimeGapMitre())
				.timeGapNvd(vulnerability.getTimeGapNvd())
				.type(parseType(vulnerability.getVdoCharacteristics()))
				.discoveredBy(parseDiscoveredBy(vulnerability.getSourceUrls()));

		if(vulnerability.getIntroducedDate() != null){
			builder.introducedDate(vulnerability.getIntroducedDate().format(dateTimeFormatter));
		} else builder.introducedDate("N/A");

		if(vulnerability.getPublishedDate() != null){
			builder.publishedDate(vulnerability.getPublishedDate().format(dateTimeFormatter));
		} else builder.publishedDate("N/A");

		if(vulnerability.getCreatedDate() != null){
			builder.createdDate(vulnerability.getCreatedDate().format(dateTimeFormatter));
		} else builder.createdDate("N/A");

		if(vulnerability.getLastModifiedDate() != null){
			builder.lastModifiedDate(vulnerability.getLastModifiedDate().format(dateTimeFormatter));
		} else builder.lastModifiedDate("N/A");

		if(vulnerability.getFixedDate() != null){
			builder.fixedDate(vulnerability.getFixedDate().format(dateFormatter));
		} else builder.fixedDate("N/A");

		for(VdoCharacteristic characteristic: vulnerability.getVdoCharacteristics()){
			builder.characteristic(VdoCharacteristicDTO.builder()
					.cveId(vulnerability.getCveId())
					.vdoLabel(characteristic.getVdoLabels().getVdoLabelName())
					.vdoConfidence(characteristic.getVdoConfidence())
					.vdoNounGroup(characteristic.getVdoGroup().getVdoGroupName())
					.build());
		}

		List<String> cpes = new ArrayList<>();
		for(AffectedRelease release: vulnerability.getAffectedReleases()){
			Product releaseProduct = release.getProduct();
			builder.product(ProductDTO.builder()
					.productId(releaseProduct.getProductId())
					.domain(releaseProduct.getDomain())
					.cpe(releaseProduct.getCpe())
					.version(release.getVersion())
					.build()
			);
			builder.cpe(release.getProduct().getCpe());
			cpes.add(release.getProduct().getCpe());
		}
		builder.domain(parseDomain(cpes));

		for(CvssScore cvss: vulnerability.getCvssScores()){
			builder.cvss(CvssDTO.builder()
					.cveId(vulnerability.getCveId())
					.baseSeverity(cvss.getCvssSeverity().getCvssSeverityClass())
					.severityConfidence(cvss.getSeverityConfidence())
					.impactScore(cvss.getImpactScore())
					.impactConfidence(cvss.getImpactConfidence())
					.build()
			);
		}

		for(VulnerabilitySourceUrl url: vulnerability.getSourceUrls()){
			builder.source(url.getUrl());
		}

		return builder.build();
	}

	@GetMapping(value = "/daily", produces = "application/json")
	public Map<LocalDate, List<VulnerabilitySummaryDTO>> getDailyVulnerabilities(@RequestParam Integer dateRange) {
		DateTimeFormatter dateFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd");
		DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");

		Map<LocalDate, List<VulnerabilityAggregate>> dailyVulns = vulnerabilityAggregateRepository.getDailyVulnerabilities(dateRange);
		return dailyVulns.entrySet()
				.stream()
				.collect(Collectors.toMap(
					e -> e.getKey(),
					e -> e.getValue().stream()
						.filter(this::removeLowQualityCve)
						.map(vuln -> {
							VulnerabilitySummaryDTO.VulnerabilitySummaryDTOBuilder builder = VulnerabilitySummaryDTO.builder();
							builder.vulnId(vuln.getVulnId())
									.cveId(vuln.getCveId())
									.description(vuln.getDescription())
									.platform(vuln.getPlatform())
									.publishedDate(vuln.getPublishedDate().format(dateTimeFormatter))
									.lastModifiedDate(vuln.getLastModifiedDate().format(dateTimeFormatter))
									.fixedDate(vuln.getFixedDate().format(dateTimeFormatter))
									.runDateTime(vuln.getRunDateTime().format(dateFormatter))
									.existInNvd(vuln.isExistInNvd())
									.existInMitre(vuln.isExistInMitre())
									.domain(vuln.getDomain())
									.version(vuln.getVersion());

							List<VdoCharacteristic> characteristics = List.of(VulnerabilityUtil.parseVDOList(vuln.getCveId(), vuln.getVdoLabels(), vuln.getVdoLabelConfidences(), vuln.getVdoNounGroups()));
							for(VdoCharacteristic characteristic: characteristics){
								builder.vdo(
									VdoCharacteristicDTO.builder()
									.cveId(characteristic.getCveId())
									.vdoLabel(characteristic.getVdoLabel())
									.vdoConfidence(characteristic.getVdoConfidence())
									.vdoNounGroup(characteristic.getVdoNounGroup())
									.build());
							}
							builder.type(parseType(characteristics));

							return builder.build();
						})
						.toList()
				));
	}

	private boolean removeLowQualityCve(VulnerabilityAggregate vuln) {
		String pattern = "\\bCVE-20\\d{2}-\\d{4,5}\\b";

		Pattern p = Pattern.compile(pattern);
		Matcher m;

		int patternLength = 0;

		m = p.matcher(vuln.getDescription());
		while (m.find())
			patternLength += m.group().length();

		return !(patternLength >= vuln.getDescription().length() * 0.9);
	}
}