/**
 * Copyright 2023 Rochester Institute of Technology (RIT). Developed with
 * government support under contract 70RSAT19CB0000020 awarded by the United
 * States Department of Homeland Security.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
package org.nvip.api.controllers;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.nvip.api.serializers.*;
import org.nvip.data.repositories.VulnerabilityRepository;
import org.nvip.entities.*;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@RestController
@RequestMapping("/vulnerabilities")
public class VulnerabilityController {

	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(VulnerabilityController.class);

final VulnerabilityRepository vulnerabilityRepository;

	public VulnerabilityController(VulnerabilityRepository vulnerabilityRepository) {
		this.vulnerabilityRepository = vulnerabilityRepository;
	}

	@GetMapping
	public List<VulnerabilitySearchDTO> getVulnerabilities(
			@RequestParam(value="startDate", required = false) @DateTimeFormat(iso=DateTimeFormat.ISO.DATE_TIME) LocalDateTime startDate,
			@RequestParam(value="endDate", required = false) @DateTimeFormat(iso=DateTimeFormat.ISO.DATE_TIME) LocalDateTime endDate,
			@RequestParam(value="cvssScore", required = false) String[] cvssScores,
			@RequestParam(value="vdoLabels", required = false) String[] vdoLabels,
			@RequestParam(value="product", required = false) String product,
			@RequestParam(value="keyword", required = false) String keyword,
			@RequestParam(value="limitCount", required = false, defaultValue="100") Integer limitCount
	) {

		Map<Integer, List<Vulnerability>> searchResults = vulnerabilityRepository.searchVulnerability(
				keyword,
				startDate,
				endDate,
				cvssScores,
				vdoLabels,
				limitCount,
				product);

		DateTimeFormatter dateFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd");
		DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm");

		return searchResults.values().stream()
				.findFirst()
				.orElseGet(List::of)
				.stream()
				.map(v -> {
					VulnerabilitySearchDTO.VulnerabilitySearchDTOBuilder builder = VulnerabilitySearchDTO.builder();
					builder.vulnId(v.getVulnId())
						.cveId(v.getCveId())
						.description(v.getDescription())
						.patch(v.getPatch())
						.existInMitre(v.isExistInMitre())
						.existInNvd(v.isExistInNvd())
						.timeGapMitre(v.getTimeGapMitre())
						.timeGapNvd(v.getTimeGapNvd());
						
					if(v.getIntroducedDate() != null){
						builder.introducedDate(v.getIntroducedDate().format(dateTimeFormatter));
					} else builder.introducedDate("N/A");

					if(v.getPublishedDate() != null){
						builder.publishedDate(v.getPublishedDate().format(dateTimeFormatter));
					} else builder.publishedDate("N/A");

					if(v.getCreatedDate() != null){
						builder.createdDate(v.getCreatedDate().format(dateTimeFormatter));
					} else builder.createdDate("N/A");

					if(v.getLastModifiedDate() != null){
						builder.lastModifiedDate(v.getLastModifiedDate().format(dateTimeFormatter));
					} else builder.lastModifiedDate("N/A");

					if(v.getFixedDate() != null){
						builder.fixedDate(v.getFixedDate().format(dateFormatter));
					} else builder.fixedDate("N/A");

					for(VdoCharacteristic characteristic: v.getVdoCharacteristics()){
						builder.characteristic(VdoCharacteristicDTO.builder()
										.cveId(v.getCveId())
										.vdoLabel(characteristic.getVdoLabels().getVdoLabelName())
										.vdoConfidence(characteristic.getVdoConfidence())
										.vdoNounGroup(characteristic.getVdoGroup().getVdoGroupName())
								.build());
					}

					for(AffectedRelease release: v.getAffectedReleases()){
						Product releaseProduct = release.getProduct();
						builder.product(ProductDTO.builder()
								.productId(releaseProduct.getProductId())
								.domain(releaseProduct.getDomain())
								.cpe(releaseProduct.getCpe())
								.version(release.getVersion())
								.build()
						);
						builder.cpe(release.getProduct().getCpe());
					}

					for(CvssScore cvss: v.getCvssScores()){
						builder.cvss(CvssDTO.builder()
								.cveId(v.getCveId())
								.baseSeverity(cvss.getCvssSeverity().getCvssSeverityClass())
								.severityConfidence(cvss.getSeverityConfidence())
								.impactScore(cvss.getImpactScore())
								.impactConfidence(cvss.getImpactConfidence())
								.build()
						);
					}

					for(VulnerabilitySourceUrl url: v.getSourceUrls()){
						builder.source(url.getUrl());
					}

					return builder.build();
				})
				.toList();
	}

	@GetMapping(value="/{id}")
	public VulnerabilitySearchDTO getVulnerability(@PathVariable(value = "id") String cveId){
		DateTimeFormatter dateFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd");
		DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm");

		Vulnerability vulnerability = vulnerabilityRepository.getByCveId(cveId);

		VulnerabilitySearchDTO.VulnerabilitySearchDTOBuilder builder = VulnerabilitySearchDTO.builder();
		builder.vulnId(vulnerability.getVulnId())
				.cveId(vulnerability.getCveId())
				.description(vulnerability.getDescription())
				.patch(vulnerability.getPatch())
				.existInMitre(vulnerability.isExistInMitre())
				.existInNvd(vulnerability.isExistInNvd())
				.timeGapMitre(vulnerability.getTimeGapMitre())
				.timeGapNvd(vulnerability.getTimeGapNvd());

		if(vulnerability.getIntroducedDate() != null){
			builder.introducedDate(vulnerability.getIntroducedDate().format(dateTimeFormatter));
		} else builder.introducedDate("N/A");

		if(vulnerability.getPublishedDate() != null){
			builder.publishedDate(vulnerability.getPublishedDate().format(dateTimeFormatter));
		} else builder.publishedDate("N/A");

		if(vulnerability.getCreatedDate() != null){
			builder.createdDate(vulnerability.getCreatedDate().format(dateTimeFormatter));
		} else builder.createdDate("N/A");

		if(vulnerability.getLastModifiedDate() != null){
			builder.lastModifiedDate(vulnerability.getLastModifiedDate().format(dateTimeFormatter));
		} else builder.lastModifiedDate("N/A");

		if(vulnerability.getFixedDate() != null){
			builder.fixedDate(vulnerability.getFixedDate().format(dateFormatter));
		} else builder.fixedDate("N/A");

		System.out.println(vulnerability.getVdoCharacteristics().size());
		for(VdoCharacteristic characteristic: vulnerability.getVdoCharacteristics()){
			builder.characteristic(VdoCharacteristicDTO.builder()
					.cveId(vulnerability.getCveId())
					.vdoLabel(characteristic.getVdoLabels().getVdoLabelName())
					.vdoConfidence(characteristic.getVdoConfidence())
					.vdoNounGroup(characteristic.getVdoGroup().getVdoGroupName())
					.build());
		}

		for(AffectedRelease release: vulnerability.getAffectedReleases()){
			Product releaseProduct = release.getProduct();
			builder.product(ProductDTO.builder()
					.productId(releaseProduct.getProductId())
					.domain(releaseProduct.getDomain())
					.cpe(releaseProduct.getCpe())
					.version(release.getVersion())
					.build()
			);
			builder.cpe(release.getProduct().getCpe());
		}

		for(CvssScore cvss: vulnerability.getCvssScores()){
			builder.cvss(CvssDTO.builder()
					.cveId(vulnerability.getCveId())
					.baseSeverity(cvss.getCvssSeverity().getCvssSeverityClass())
					.severityConfidence(cvss.getSeverityConfidence())
					.impactScore(cvss.getImpactScore())
					.impactConfidence(cvss.getImpactConfidence())
					.build()
			);
		}

		for(VulnerabilitySourceUrl url: vulnerability.getSourceUrls()){
			builder.source(url.getUrl());
		}

		return builder.build();
	}

	@GetMapping(value = "/search", produces = "application/json")
	public List<Vulnerability> search(@RequestBody Map<String, String> searchParams) {

		//TODO: Spring Security
//		String userName = req.getParameter("username");
//		String token = req.getParameter("token");
//
//		if (userName == null || token == null)
//			ServletUtil.setResponse(resp, 401, "Unauthorized user!");
//
//		User user = UserDAO.getRoleIDandExpirationDate(userName, token);
//
//		if (user == null)
//			ServletUtil.setResponse(resp, 401, "Unauthorized user!");


		//TODO: Move this to a get endpoint that returns the search info
//		// Section for Search Form info. Used when Search Form is initialized
//		boolean searchInfo = Boolean.parseBoolean(req.getParameter("searchInfo"));
//		if (searchInfo) {
//			Map<String, Map<String, String[]>> searchMap = SearchDAO.getSearchInfo();
//			map = new JsonObject();
//
//			String jObj = gson.toJson(searchMap);
//
//			generateResp(jObj, resp);
//
//			return; // End the method
//		}

		String keyword = searchParams.getOrDefault("keyword", "").split(" ")[0];

		LocalDateTime startDate = searchParams.get("startDate") == null ? null
				: LocalDateTime.parse(searchParams.get("startDate"));
		LocalDateTime endDate = searchParams.get("endDate") == null ? null
				: LocalDateTime.parse(searchParams.get("endDate"));
		String[] cvssScores = searchParams.get("cvssScores") == null ? null
				: searchParams.get("cvssScores").split(",");
		String[] vdoLabels = searchParams.get("vdoLabels") == null ? null
				: searchParams.get("vdoLabels").split(",");
		int limitCount = searchParams.get("limitCount") == null ? 0
				: Integer.parseInt(searchParams.get("limitCount"));
		String product = searchParams.getOrDefault("product", null);

		Map<Integer, List<Vulnerability>> searchResults = vulnerabilityRepository.searchVulnerability(keyword, startDate,
				endDate, cvssScores, vdoLabels, limitCount, product);

		return searchResults.values().stream().findFirst().orElseGet(List::of);
	}

	@GetMapping(value = "/daily", produces = "application/json")
	public List<Vulnerability> getDailyVulnerabilities() {

//		int dateRange = req.getParameter("dateRange") == null ? 0
//				: Integer.parseInt(req.getParameter("dateRange"));
//		Map<LocalDate, List<Vulnerability>> dailyVulns = VulnerabilityDAO.getDailyVulnerabilities(dateRange);
//
//		removeLowQualityCves(dailyVulns);
//
//		int i = 0;
//		for (LocalDate date : dailyVulns.keySet().stream().sorted((e1, e2) -> e2.compareTo(e1))
//				.collect(Collectors.toList())) {
//			dailyVulnsJson = new JsonObject();
//
//			dailyVulnsJson.add("date", gson.toJsonTree(date, LocalDate.class));
//			dailyVulnsJson.add("list", toJsonArray(gson, dailyVulns.get(date), List.class));
//
//			allVunsJson.add(i + "", gson.toJsonTree(dailyVulnsJson));
//			i++;
//		}
//
		return List.of();
	}

	private void removeLowQualityCves(Map<LocalDate, List<Vulnerability>> dailyVulns) {
		String pattern = "\\bCVE-20\\d{2}-\\d{4,5}\\b";

		Pattern p = Pattern.compile(pattern);
		Matcher m;

		int patternLength = 0;

		for (LocalDate date : dailyVulns.keySet()) {
			List<Vulnerability> vulns = dailyVulns.get(date);
			for (int i = 0; i < vulns.size(); i++) {
				m = p.matcher(vulns.get(i).getDescription());
				while (m.find())
					patternLength += m.group().length();

				if (patternLength >= vulns.get(i).getDescription().length() * 0.9) {
					vulns.remove(i);
					i--; // Decrement so on same position in list
				}

				patternLength = 0;
			}
		}
	}
}