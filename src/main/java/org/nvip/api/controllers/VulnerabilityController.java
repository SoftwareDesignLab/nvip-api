/**
 * Copyright 2023 Rochester Institute of Technology (RIT). Developed with
 * government support under contract 70RSAT19CB0000020 awarded by the United
 * States Department of Homeland Security.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
package org.nvip.api.controllers;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.nvip.api.serializers.*;
import org.nvip.data.repositories.VulnerabilityAggregateRepository;
import org.nvip.data.repositories.VulnerabilityRepository;
import org.nvip.entities.*;
import org.nvip.util.CvssGenUtil;
import org.nvip.util.VulnerabilityUtil;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.web.bind.annotation.*;

import javax.net.ssl.HttpsURLConnection;
import java.io.IOException;
import java.net.URL;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/vulnerabilities")
public class VulnerabilityController {

	private static final Logger logger = LogManager.getLogger(VulnerabilityController.class);
	private static final ObjectMapper OM = new ObjectMapper();

	@Value("${ssvc.api.url}")
	String ssvcApiUrl;

	final VulnerabilityRepository vulnerabilityRepository;
	final VulnerabilityAggregateRepository vulnerabilityAggregateRepository;

	@Autowired VulnerabilityUtil vulnerabilityUtil;
	@Autowired CvssGenUtil cvssGenUtil;

	public VulnerabilityController(VulnerabilityRepository vulnerabilityRepository, VulnerabilityAggregateRepository vulnerabilityAggregateRepository) {
		this.vulnerabilityRepository = vulnerabilityRepository;
		this.vulnerabilityAggregateRepository = vulnerabilityAggregateRepository;
	}

	@GetMapping
	public List<VulnerabilitySummaryDTO> getVulnerabilities(
			@RequestParam(value="startDate", required = false) @DateTimeFormat(iso=DateTimeFormat.ISO.DATE) LocalDate startDate,
			@RequestParam(value="endDate", required = false) @DateTimeFormat(iso=DateTimeFormat.ISO.DATE) LocalDate endDate,
			@RequestParam(value="cvssScores", required = false) int[] cvssScores,
			@RequestParam(value="vdoLabels", required = false) String[] vdoLabels,
			@RequestParam(value="product", required = false) String product,
			@RequestParam(value="keyword", required = false) String keyword,
			@RequestParam(value="limitCount", required = false, defaultValue="100") Integer limitCount
	) {

		//TODO: Spring Security
		//		String userName = req.getParameter("username");
		//		String token = req.getParameter("token");
		//
		//		if (userName == null || token == null)
		//			ServletUtil.setResponse(resp, 401, "Unauthorized user!");
		//
		//		User user = UserDAO.getRoleIDandExpirationDate(userName, token);
		//
		//		if (user == null)
		//			ServletUtil.setResponse(resp, 401, "Unauthorized user!");

		LocalDateTime startDateParam = (startDate == null) ? null : LocalDateTime.of(startDate, LocalTime.now());
		LocalDateTime endDateParam = (endDate == null) ? null : LocalDateTime.of(endDate, LocalTime.now());

		List<Vulnerability> searchResults = vulnerabilityRepository.searchVulnerability(
				keyword,
				startDateParam,
				endDateParam,
				cvssScores,
				vdoLabels,
				limitCount,
				product);

		DateTimeFormatter dateFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd");
		DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");

		return searchResults.stream()
				.map(v -> {
					VulnerabilitySummaryDTO.VulnerabilitySummaryDTOBuilder builder = VulnerabilitySummaryDTO.builder();

					Description desc = v.getDescription();

					builder.vulnId(v.getVulnId())
							.cveId(v.getCveId())
							.description(desc.getDescription())
							.existInMitre(v.existsInMitre())
							.existInNvd(v.existsInNvd())
							.type(parseType(v.getVdoCharacteristics()));

					Description altDescription = vulnerabilityUtil.getAltDescription(desc);
					builder.altDescription(DescriptionDTO.builder()
							.description(altDescription.getDescription())
							.isUserGenerated(altDescription.getIsUserGenerated())
							.build());

					if(v.getPublishedDate() != null){
						builder.publishedDate(v.getPublishedDate().format(dateTimeFormatter));
					} else builder.publishedDate("N/A");

					if(v.getLastModifiedDate() != null){
						builder.lastModifiedDate(v.getLastModifiedDate().format(dateTimeFormatter));
					} else builder.lastModifiedDate("N/A");

					if(v.getCreatedDate() != null){
						builder.createdDate(v.getCreatedDate().format(dateFormatter));
					}

					for(VdoCharacteristic characteristic: v.getVdoCharacteristics()){
						builder.vdo(VdoCharacteristicDTO.builder()
								.cveId(v.getCveId())
								.vdoLabel(characteristic.getVdoLabel())
								.vdoConfidence(characteristic.getVdoConfidence())
								.vdoNounGroup(characteristic.getVdoNounGroup())
								.build());
					}
					builder.type(parseType(v.getVdoCharacteristics()));

					List<String> cpes = new ArrayList<>();
					for(AffectedProduct release: v.getAffectedProducts()){
						cpes.add(release.getCpe());
					}
					builder.domain(parseDomain(cpes));

					return builder.build();
				})
				.toList();
	}

	private String parseType(List<VdoCharacteristic> vdoCharacteristics){
		String type = vdoCharacteristics.stream()
				.filter(x -> x.getVdoNounGroup().contains("IMPACT_METHOD"))
				.map(x -> x.getVdoNounGroup())
				.distinct()
				.collect(Collectors.joining(", "));
		return type.isEmpty() ? "N/A" : type;
	}

	private String parseDomain(List<String> cpes) {
		String domain = "N/A";
		if (cpes != null && cpes.size() > 0) {
			domain = VulnerabilityUtil.getCompanyProduct(cpes.get(0));
		}
		return domain;
	}

	@GetMapping(value="/{id}")
	public VulnerabilitySearchDTO getVulnerability(@PathVariable(value = "id") String cveId) {
		DateTimeFormatter dateFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd");
		DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");

		Vulnerability vulnerability = vulnerabilityRepository.getByCveId(cveId);

		VulnerabilitySearchDTO.VulnerabilitySearchDTOBuilder builder = VulnerabilitySearchDTO.builder();
		builder.vulnId(vulnerability.getVulnId())
				.cveId(vulnerability.getCveId())
				.description(vulnerability.getDescription().getDescription())
				.existInMitre(vulnerability.existsInMitre())
				.existInNvd(vulnerability.existsInNvd())
				.type(parseType(vulnerability.getVdoCharacteristics()));

		// if description is system generated, try to find a user generated altDesc
		// if description is user generated, definitely find the most recent system generated altDesc
		Description altDescription = vulnerabilityUtil.getAltDescription(vulnerability.getDescription());
		if (altDescription == null) // case where there's no user desc
			builder.description(vulnerability.getDescriptionString());
		else if (altDescription.getIsUserGenerated() == 1) { // case where user desc exists, this should trump system desc
			builder.description(altDescription.getDescription());
			builder.altDescription(DescriptionDTO.builder()
					.description(vulnerability.getDescriptionString())
					.createdDate(vulnerability.getDescription().getCreatedDate().format(dateFormatter))
					.isUserGenerated(vulnerability.getDescription().getIsUserGenerated())
					.build());
		}
		else { // case where alt desc is system generated, main desc is user generated, no need to switch anything
			builder.description(vulnerability.getDescriptionString());
			builder.altDescription(DescriptionDTO.builder()
					.description(altDescription.getDescription())
					.createdDate(altDescription.getCreatedDate().format(dateFormatter))
					.isUserGenerated(altDescription.getIsUserGenerated())
			.build());
		}


		builder.introducedDate("N/A");

		if(vulnerability.getPublishedDate() != null){
			builder.publishedDate(vulnerability.getPublishedDate().format(dateTimeFormatter));
		} else builder.publishedDate("N/A");

		if(vulnerability.getCreatedDate() != null){
			builder.createdDate(vulnerability.getCreatedDate().format(dateTimeFormatter));
		} else builder.createdDate("N/A");

		if(vulnerability.getLastModifiedDate() != null){
			builder.lastModifiedDate(vulnerability.getLastModifiedDate().format(dateTimeFormatter));
		} else builder.lastModifiedDate("N/A");

		builder.fixedDate("N/A");

		List<VdoCharacteristic> characteristics = vulnerability.getVdoCharacteristics();
		// filter VDO labels by vdoLabel, max by createdDate
		characteristics = characteristics.stream()
				.collect(Collectors.groupingBy(VdoCharacteristic::getVdoLabel))
				.values()
				.stream()
				.map(x -> x.stream().max(Comparator.comparing(VdoCharacteristic::getCreatedDate)).get())
				.collect(Collectors.toList());

		for(VdoCharacteristic characteristic: characteristics){
			builder.characteristic(VdoCharacteristicDTO.builder()
					.cveId(vulnerability.getCveId())
					.vdoLabel(characteristic.getVdoLabel())
					.vdoConfidence(characteristic.getVdoConfidence())
					.vdoNounGroup(characteristic.getVdoNounGroup())
					.userId(characteristic.getUserId())
					.isActive(characteristic.getIsActive())
					.build());
		}

		List<String> cpes = new ArrayList<>();
		for(AffectedProduct product: vulnerability.getAffectedProducts()){
			builder.product(ProductDTO.builder()
					.productId(product.getAffectedProductId())
					.productName(product.getProductName())
					.cpe(product.getCpe())
					.version(product.getVersion())
					.build());
			builder.cpe(product.getCpe());
			cpes.add(product.getCpe());
		}
		builder.domain(parseDomain(cpes));

//		if (vulnerability.getCvssScore() != null)
//			builder.cvssScore(CvssDTO.builder()
//					.cveId(vulnerability.getCveId())
//					.baseScore(vulnerability.getCvssScore().getBaseScore())
//					.build());

		//TODO: we dont need cve id in these objects

		for(RawDescription rawDesc: vulnerability.getRawDescriptions()){
			builder.source(
					RawDescriptionDTO.builder()
							.cveId(vulnerability.getCveId())
							.rawDescription(rawDesc.getRawDescription())
							.createdDate(String.valueOf(rawDesc.getCreatedDate()))
							.publishedDate(String.valueOf(rawDesc.getPublishedDate()))
							.lastModifiedDate(String.valueOf(rawDesc.getLastModifiedDate()))
							.sourceUrl(rawDesc.getSourceUrl())
							.isGarbage(rawDesc.getIsGarbage())
							.sourceType(rawDesc.getSourceType())
							.parserType(rawDesc.getParserType())
							.build()
			);
		}

		// TODO: this ultimately replaces all previous CVSS storing using a simple lookup
		// get rid of old CVSS table and code when ready
		// get rid of CVSS insertions
		Double calculatedCVSSScore = cvssGenUtil.calculateCVSSScore(characteristics);

		if (calculatedCVSSScore != null) {
			builder.cvssScore(CvssDTO.builder()
					.cveId(vulnerability.getCveId())
					.baseScore(calculatedCVSSScore)
					.build());
		}

		for (PatchCommit patch : vulnerability.getPatchCommits()) {
			builder.patchCommit(
					PatchCommitDTO.builder()
							.cveId(vulnerability.getCveId())
							.sourceUrl(patch.getSourceUrl().getSourceUrl())
							.commitSha(patch.getCommitSha())
							.commitMessage(patch.getCommitMessage())
							.commitDate(String.valueOf(patch.getCommitDate()))
							.linesChanged(patch.getLinesChanged())
							.build()
			);
		}

		for (Fix fix : vulnerability.getFixes()) {
			builder.fix(
					FixDTO.builder()
							.cveId(vulnerability.getCveId())
							.sourceUrl(fix.getSourceUrl())
							.fixDescription(fix.getFixDescription())
							.build()
			);
		}

		for (Exploit exploit : vulnerability.getExploits()) {
			builder.exploit(
					ExploitDTO.builder()
							.cveId(vulnerability.getCveId())
							.source(exploit.getSource())
							.sourceUrl(exploit.getSourceUrl())
							.description(exploit.getDescription())
							.dateCreated(String.valueOf(exploit.getDateCreated()))
							.datePublished(String.valueOf(exploit.getDatePublished()))
							.isRepo(exploit.isRepo())
							.build()
			);
		}

		// Build SSVC scores via SSVC API
		SSVC ssvc = vulnerability.getSsvc();
		final SSVCScoreDTO SSVCScores = getSSVCScores(ssvc);
		//TODO: Quick null check in case ssvc is not returned. Need to handle this more elegantly
		if(SSVCScores != null){
			final String[] missAndWbValues = {"LOW", "MEDIUM", "HIGH"};
			for (int i = 0; i < missAndWbValues.length; i++) {
				final String score = SSVCScores.get(i);
				final String mwb = missAndWbValues[i];
				builder.ssvc(
						SSVCDTO.builder()
								.cveId(vulnerability.getCveId())
								.missionAndWellbeing(mwb)
								.score(score)
								.build()
				);
			}
		}

		return builder.build();
	}

	// ALWAYS EXPECTS 3 VALUES, LESS WILL CAUSE AN ERROR, MORE WILL BE TRUNCATED
	private SSVCScoreDTO getSSVCScores(SSVC ssvc) {
		// Ensure no NullPointerExceptions
		if(ssvc == null) return null;

		// TODO: Query SSVC for decision on score based on collected characteristics
		final StringBuilder params = new StringBuilder();
		params.append("?automatable=");
		params.append(ssvc.isAutomatable() ? "TRUE" : "FALSE");
		params.append("&exploitStatus=");
		params.append(ssvc.getExploitStatus());
		params.append("&technicalImpact=");
		params.append(ssvc.isTechnicalImpact() ? "TOTAL" : "PARTIAL");

		try {
			final URL url = new URL("http://" + ssvcApiUrl + "/quickssvc" + params.toString());
			logger.info("Fetching SSVC Information from {}", url.toString());
			return OM.readValue(url, SSVCScoreDTO.class);
		}
		catch (IOException e) { logger.error("Failed to query SSVC scoring API: {}", e.toString()); }
		return null;
	}


	private VulnerabilitySummaryDTO mapVuln(Vulnerability vuln) {
		DateTimeFormatter dateFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd");
		DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
		VulnerabilitySummaryDTO.VulnerabilitySummaryDTOBuilder builder = VulnerabilitySummaryDTO.builder();
		builder.vulnId(vuln.getVulnId())
				.cveId(vuln.getCveId())
				.description(vuln.getDescriptionString().length() < 297 ? vuln.getDescriptionString() : vuln.getDescriptionString().substring(0, 297)+"...")
//				.platform(vuln.getPlatform())
				.publishedDate(
						vuln.getPublishedDate() != null ? vuln.getPublishedDate().format(dateTimeFormatter) : "N/A"
				)
				.lastModifiedDate(
						vuln.getLastModifiedDate() != null ? vuln.getLastModifiedDate().format(dateTimeFormatter) : "N/A")
				.createdDate(vuln.getCreatedDate().format(dateFormatter))
				.existInNvd(vuln.existsInNvd())
				.existInMitre(vuln.existsInMitre())
//				.domain(vuln.getDomain())
//				.version(vuln.getVersion())
		;

//		for(VdoCharacteristic characteristic: vuln.getVdoList()){
//			builder.vdo(
//					VdoCharacteristicDTO.builder()
//							.cveId(characteristic.getCveId())
//							.vdoLabel(characteristic.getVdoLabel())
//							.vdoConfidence(characteristic.getVdoConfidence())
//							.vdoNounGroup(characteristic.getVdoNounGroup())
//							.build());
//		}
//		builder.type(parseType(characteristics));

		return builder.build();
	}

	@GetMapping(value = "/daily", produces = "application/json")
	public Map<LocalDate, List<VulnerabilitySummaryDTO>> getDailyVulnerabilities(@RequestParam Integer dateRange) {
		Map<LocalDate, List<VulnerabilityAggregate>> dailyVulns = vulnerabilityAggregateRepository.getDailyVulnerabilities(dateRange);
		return dailyVulns.entrySet()
				.stream()
				.collect(Collectors.toMap(
					e -> e.getKey(),
					e -> e.getValue().stream()
							.filter(this::removeLowQualityCve)
							.sorted(
									Comparator.comparing(VulnerabilityAggregate::isExistInNvd)
											.thenComparing(VulnerabilityAggregate::getCveId, Comparator.reverseOrder())
							)
							.map(vuln -> {
								VulnerabilitySummaryDTO.VulnerabilitySummaryDTOBuilder builder = VulnerabilitySummaryDTO.builder();
								builder.vulnId(vuln.getVulnId())
										.cveId(vuln.getCveId())
										.description(vuln.getDescription().length() < 297 ? vuln.getDescription() : vuln.getDescription().substring(0, 297)+"...")
//										.publishedDate(
//												vuln.getPublishedDate() != null ? vuln.getPublishedDate().format(dateTimeFormatter) : "N/A"
//										)
//										.lastModifiedDate(
//												vuln.getLastModifiedDate() != null ? vuln.getLastModifiedDate().format(dateTimeFormatter) : "N/A")
//										.createdDate(vuln.getCreatedDate().format(dateFormatter))
										.numPatches(Integer.toString(vuln.getPatchCommits().size()))
										.existInNvd(vuln.isExistInNvd())
										.existInMitre(vuln.isExistInMitre());
								// List<VdoCharacteristic> characteristics = List.of(vulnerabilityUtil.parseVDOList(vuln.getCveId(), vuln.getVdoLabels(), vuln.getVdoLabelConfidences(), vuln.getVdoNounGroups()));
								for(VdoCharacteristic characteristic: vuln.getVdoList()){
									builder.vdo(
										VdoCharacteristicDTO.builder()
										.cveId(characteristic.getVulnerability().getCveId())
										.vdoLabel(characteristic.getVdoLabel())
										.vdoConfidence(characteristic.getVdoConfidence())
										.vdoNounGroup(characteristic.getVdoNounGroup())
										.build());
								}
								builder.type(parseType(vuln.getVdoList()));

								for (Fix fix : vuln.getFixes()) {
									builder.fix(
											FixDTO.builder()
													.cveId(vuln.getCveId())
													.sourceUrl(fix.getSourceUrl())
													.fixDescription(fix.getFixDescription())
													.build()
									);
								}

								return builder.build();
							})
							.toList()
				));
	}

	@GetMapping(value = "/dailyPage", produces = "application/json")
	public List<VulnerabilitySummaryDTO> getDailyVulnerabilitiesByDate(@RequestParam String date, @RequestParam Integer pageNum, @RequestParam Integer pageSize) {
		List<Vulnerability> dailyVulns = vulnerabilityAggregateRepository.getVulnerabilitiesByDate(date, pageNum, pageSize);
		return dailyVulns.stream().map(this::mapVuln).toList();
	}

	@GetMapping(value = "/dailyPageCount", produces = "application/json")
	public Object getVulnerabilitiesCount(@RequestParam Integer dateRange) {
		return vulnerabilityAggregateRepository.getVulnCountRange(dateRange);
	}

	private boolean removeLowQualityCve(VulnerabilityAggregate vuln) {
		String pattern = "\\bCVE-20\\d{2}-\\d{4,5}\\b";

		Pattern p = Pattern.compile(pattern);
		Matcher m = p.matcher(vuln.getDescription());;

		int patternLength = 0;

		while (m.find())
			patternLength += m.group().length();

		return !(patternLength >= vuln.getDescription().length() * 0.9);
	}
}